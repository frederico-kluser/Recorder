[
  {
    "path": "src/pages/Popup/components/recording-detail.css",
    "sha": "54faa3ed7948effd22a31ff1504e9d1be9110b49",
    "size": 9074,
    "summary": "O código CSS apresentado define o estilo para o componente RecordingDetail, que oferece uma visualização detalhada de gravações com tema dark, focando em alta qualidade visual e usabilidade. Ele estrutura o layout em flexbox, organiza cabeçalhos, metadados, áreas de conteúdo, abas de navegação, barras de ferramentas e botões com estados interativos, além de suportar responsividade para dispositivos móveis. O componente também inclui animações suaves, barras de progresso customizadas e tratamento visual para estados de erro e carregamento, garantindo uma experiência consistente e acessível para usuários que precisam analisar e interagir com gravações de forma eficiente e visualmente agradável.",
    "content": "/**\n * Estilos específicos para o componente RecordingDetail\n * Visualização detalhada com tema dark e alta qualidade visual\n */\n\n/* Container principal dos detalhes */\n.recording-detail {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  background-color: var(--bg-dark);\n  color: var(--text-primary);\n}\n\n/* Header dos detalhes */\n.recording-detail-header {\n  padding: var(--spacing-lg);\n  background-color: var(--bg-darker);\n  border-bottom: 1px solid var(--border-color);\n  display: flex;\n  align-items: flex-start;\n  justify-content: space-between;\n  gap: var(--spacing-md);\n}\n\n.recording-detail-header-info {\n  flex: 1;\n  min-width: 0;\n}\n\n.recording-detail-title {\n  font-size: var(--font-lg);\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-sm);\n  margin: 0 0 var(--spacing-sm) 0;\n  color: var(--text-primary);\n}\n\n.recording-detail-title-text {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* Metadados */\n.recording-detail-meta {\n  display: flex;\n  flex-wrap: wrap;\n  gap: var(--spacing-lg);\n  font-size: var(--font-sm);\n  color: var(--text-secondary);\n}\n\n.recording-detail-meta-item {\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-xs);\n}\n\n.recording-detail-meta-icon {\n  color: var(--text-muted);\n}\n\n.recording-detail-meta-url {\n  max-width: 200px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* Área de conteúdo */\n.recording-detail-content {\n  flex: 1;\n  padding: var(--spacing-lg);\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  gap: var(--spacing-lg);\n}\n\n/* Barra de ferramentas */\n.recording-detail-toolbar {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--spacing-md);\n  flex-wrap: wrap;\n}\n\n/* Tabs de visualização */\n.recording-detail-tabs {\n  display: flex;\n  gap: var(--spacing-sm);\n  background-color: var(--bg-card);\n  padding: var(--spacing-xs);\n  border-radius: var(--radius-md);\n}\n\n.recording-detail-tab {\n  padding: var(--spacing-sm) var(--spacing-md);\n  background-color: transparent;\n  border: none;\n  border-radius: var(--radius-sm);\n  color: var(--text-secondary);\n  font-size: var(--font-sm);\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-xs);\n}\n\n.recording-detail-tab:hover {\n  color: var(--text-primary);\n  background-color: var(--bg-hover);\n}\n\n.recording-detail-tab.active {\n  background-color: var(--bg-darker);\n  color: var(--primary);\n}\n\n/* Ações da toolbar */\n.recording-detail-actions {\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-md);\n}\n\n.recording-detail-script-type {\n  font-size: var(--font-sm);\n  color: var(--text-muted);\n  padding: var(--spacing-xs) var(--spacing-sm);\n  background-color: var(--bg-card);\n  border-radius: var(--radius-sm);\n  font-weight: 500;\n}\n\n/* Área de visualização */\n.recording-detail-view {\n  flex: 1;\n  overflow: hidden;\n  background-color: var(--bg-card);\n  border-radius: var(--radius-lg);\n  border: 1px solid var(--border-color);\n}\n\n/* Container de ações */\n.recording-detail-actions-view {\n  height: 100%;\n  overflow-y: auto;\n  padding: var(--spacing-lg);\n}\n\n/* Container de código */\n.recording-detail-code-view {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n\n.recording-detail-code-header {\n  padding: var(--spacing-md) var(--spacing-lg);\n  background-color: var(--bg-darker);\n  border-bottom: 1px solid var(--border-color);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.recording-detail-code-title {\n  font-size: var(--font-sm);\n  font-weight: 600;\n  color: var(--text-secondary);\n}\n\n.recording-detail-code-content {\n  flex: 1;\n  overflow: auto;\n  padding: var(--spacing-lg);\n  background-color: var(--bg-code);\n  font-family: var(--font-mono);\n  font-size: var(--font-sm);\n  line-height: 1.6;\n}\n\n/* Botões personalizados */\n.recording-btn {\n  padding: var(--spacing-sm) var(--spacing-md);\n  border: none;\n  border-radius: var(--radius-md);\n  font-size: var(--font-sm);\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  display: inline-flex;\n  align-items: center;\n  gap: var(--spacing-xs);\n  white-space: nowrap;\n}\n\n.recording-btn:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.recording-btn:active {\n  transform: translateY(0);\n  box-shadow: none;\n}\n\n.recording-btn-primary {\n  background-color: var(--primary);\n  color: var(--white);\n}\n\n.recording-btn-primary:hover {\n  background-color: var(--primary-hover);\n}\n\n.recording-btn-secondary {\n  background-color: var(--bg-button);\n  color: var(--text-primary);\n  border: 1px solid var(--border-color);\n}\n\n.recording-btn-secondary:hover {\n  background-color: var(--bg-hover);\n  border-color: var(--border-hover);\n}\n\n.recording-btn-success {\n  background-color: var(--success);\n  color: var(--white);\n}\n\n.recording-btn-back {\n  background-color: var(--bg-button);\n  color: var(--text-primary);\n  border: 1px solid var(--border-color);\n}\n\n.recording-btn-back:hover {\n  background-color: var(--bg-hover);\n  border-color: var(--primary);\n  color: var(--primary);\n}\n\n/* Botão danger para parar replay */\n.recording-btn-danger {\n  background-color: #dc3545;\n  color: white;\n}\n\n.recording-btn-danger:hover {\n  background-color: #c82333;\n}\n\n/* Select para modo de replay */\n.recording-select {\n  padding: var(--spacing-sm) var(--spacing-md);\n  border: 1px solid var(--border-color);\n  border-radius: var(--radius-md);\n  background-color: var(--bg-button);\n  color: var(--text-primary);\n  font-size: var(--font-sm);\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  min-width: 130px;\n}\n\n.recording-select:hover {\n  background-color: var(--bg-hover);\n  border-color: var(--border-hover);\n}\n\n.recording-select:focus {\n  outline: none;\n  border-color: var(--primary);\n  box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);\n}\n\n/* Status do replay */\n.recording-detail-replay-status {\n  background-color: var(--bg-darker);\n  border-bottom: 1px solid var(--border-color);\n  padding: var(--spacing-md) var(--spacing-lg);\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-sm);\n}\n\n.recording-detail-replay-status.error {\n  background-color: rgba(220, 53, 69, 0.1);\n  border-color: rgba(220, 53, 69, 0.3);\n}\n\n.recording-detail-replay-status-content {\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-sm);\n  flex: 1;\n  color: var(--text-secondary);\n  font-size: var(--font-sm);\n}\n\n.recording-detail-replay-status.error .recording-detail-replay-status-content {\n  color: #dc3545;\n}\n\n/* Barra de progresso do replay */\n.recording-detail-replay-progress {\n  flex: 1;\n  height: 4px;\n  background-color: var(--bg-lightest);\n  border-radius: 2px;\n  overflow: hidden;\n  margin-left: var(--spacing-md);\n}\n\n.recording-detail-replay-progress-bar {\n  height: 100%;\n  background-color: var(--accent-color);\n  transition: width 0.3s ease-out;\n}\n\n/* Estados especiais */\n.recording-detail-loading {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: var(--text-secondary);\n  gap: var(--spacing-sm);\n}\n\n.recording-detail-error {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  padding: var(--spacing-xl);\n  text-align: center;\n}\n\n.recording-detail-error-icon {\n  font-size: 48px;\n  color: var(--error);\n  margin-bottom: var(--spacing-lg);\n}\n\n.recording-detail-error-text {\n  color: var(--text-secondary);\n  margin-bottom: var(--spacing-md);\n}\n\n/* Responsividade */\n@media (max-width: 600px) {\n  .recording-detail-header {\n    flex-direction: column;\n    align-items: stretch;\n    padding: var(--spacing-md);\n  }\n\n  .recording-detail-content {\n    padding: var(--spacing-md);\n  }\n\n  .recording-detail-toolbar {\n    flex-direction: column;\n    align-items: stretch;\n  }\n\n  .recording-detail-tabs {\n    width: 100%;\n    justify-content: center;\n  }\n\n  .recording-detail-actions {\n    width: 100%;\n    justify-content: center;\n  }\n\n  .recording-detail-meta {\n    font-size: var(--font-xs);\n    gap: var(--spacing-md);\n  }\n}\n\n/* Animações */\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    transform: translateY(10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.recording-detail-view {\n  animation: fadeIn 0.3s ease-out;\n}\n\n/* Scrollbar customizada */\n.recording-detail-actions-view::-webkit-scrollbar,\n.recording-detail-code-content::-webkit-scrollbar {\n  width: 8px;\n}\n\n.recording-detail-actions-view::-webkit-scrollbar-track,\n.recording-detail-code-content::-webkit-scrollbar-track {\n  background: var(--bg-darker);\n  border-radius: var(--radius-sm);\n}\n\n.recording-detail-actions-view::-webkit-scrollbar-thumb,\n.recording-detail-code-content::-webkit-scrollbar-thumb {\n  background: var(--scrollbar-thumb);\n  border-radius: var(--radius-sm);\n}\n\n.recording-detail-actions-view::-webkit-scrollbar-thumb:hover,\n.recording-detail-code-content::-webkit-scrollbar-thumb:hover {\n  background: var(--scrollbar-thumb-hover);\n}",
    "processedAt": "2025-07-21T04:25:09.289Z"
  },
  {
    "path": "src/modules/replay/replay-runner.ts",
    "sha": "8a2d558832b61d5e653f7e89699e9b574fcf04db",
    "size": 9300,
    "summary": "O módulo ReplayRunner é responsável por executar sequências de ações gravadas em uma nova aba do navegador, simulando interações reais do usuário como cliques, digitação e navegação. Ele implementa mecanismos robustos de retry, espera ativa por elementos DOM, e controle de fluxo para garantir a execução fiel das ações, incluindo limpeza de cache e recarga da página quando necessário. A arquitetura do código prioriza a confiabilidade e a integração com o sistema de mensagens do Chrome Extension, permitindo comunicação assíncrona e controle detalhado do progresso e erros durante a reprodução das ações.",
    "content": "/**\n * ReplayRunner - Módulo responsável por executar as ações gravadas em nova aba\n * Injeta script na página para reproduzir interações do usuário\n */\n\nimport type { Action } from '../../pages/types/index';\nimport { ActionType } from '../../pages/types/index';\nimport type { ActionExecutorOptions, ActionExecutionResult, ReplayExecute, ReplayResult } from '../../types/replay';\nimport { ReplayMode } from '../../types/replay';\n\n/**\n * Executa uma ação de clique no elemento\n */\nasync function executeClick(selector: string, options: ActionExecutorOptions): Promise<ActionExecutionResult> {\n  const startTime = Date.now();\n  const { retryAttempts = 3, retryDelay = 500, waitTimeout = 5000 } = options;\n  \n  for (let attempt = 0; attempt < retryAttempts; attempt++) {\n    try {\n      // Aguarda elemento aparecer com timeout\n      const element = await waitForElement(selector, waitTimeout);\n      \n      if (!element) {\n        throw new Error(`Elemento não encontrado: ${selector}`);\n      }\n      \n      // Scroll até elemento se necessário\n      element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      await sleep(100);\n      \n      // Simula clique real\n      const clickEvent = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        view: window\n      });\n      \n      element.dispatchEvent(clickEvent);\n      \n      return {\n        success: true,\n        duration: Date.now() - startTime\n      };\n    } catch (error) {\n      if (attempt === retryAttempts - 1) {\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Erro desconhecido',\n          duration: Date.now() - startTime\n        };\n      }\n      await sleep(retryDelay);\n    }\n  }\n  \n  return {\n    success: false,\n    error: 'Máximo de tentativas excedido',\n    duration: Date.now() - startTime\n  };\n}\n\n/**\n * Executa uma ação de digitação em input\n */\nasync function executeType(selector: string, value: string, options: ActionExecutorOptions): Promise<ActionExecutionResult> {\n  const startTime = Date.now();\n  const { retryAttempts = 3, retryDelay = 500, waitTimeout = 5000 } = options;\n  \n  for (let attempt = 0; attempt < retryAttempts; attempt++) {\n    try {\n      const element = await waitForElement(selector, waitTimeout) as HTMLInputElement | HTMLTextAreaElement;\n      \n      if (!element) {\n        throw new Error(`Elemento não encontrado: ${selector}`);\n      }\n      \n      // Foca no elemento\n      element.focus();\n      await sleep(50);\n      \n      // Limpa valor existente\n      element.value = '';\n      \n      // Digita caractere por caractere para simular usuário real\n      for (const char of value) {\n        element.value += char;\n        element.dispatchEvent(new Event('input', { bubbles: true }));\n        await sleep(20 + Math.random() * 30); // Variação para parecer humano\n      }\n      \n      // Dispara evento change\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      \n      return {\n        success: true,\n        duration: Date.now() - startTime\n      };\n    } catch (error) {\n      if (attempt === retryAttempts - 1) {\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Erro desconhecido',\n          duration: Date.now() - startTime\n        };\n      }\n      await sleep(retryDelay);\n    }\n  }\n  \n  return {\n    success: false,\n    error: 'Máximo de tentativas excedido',\n    duration: Date.now() - startTime\n  };\n}\n\n/**\n * Executa navegação para nova URL\n */\nasync function executeNavigate(url: string): Promise<ActionExecutionResult> {\n  const startTime = Date.now();\n  \n  try {\n    window.location.href = url;\n    \n    return {\n      success: true,\n      duration: Date.now() - startTime\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro ao navegar',\n      duration: Date.now() - startTime\n    };\n  }\n}\n\n/**\n * Aguarda elemento aparecer no DOM\n */\nasync function waitForElement(selector: string, timeout: number): Promise<Element | null> {\n  const startTime = Date.now();\n  \n  return new Promise((resolve) => {\n    // Tenta encontrar imediatamente\n    const element = document.querySelector(selector);\n    if (element) {\n      resolve(element);\n      return;\n    }\n    \n    // Observer para detectar quando elemento aparecer\n    const observer = new MutationObserver(() => {\n      const element = document.querySelector(selector);\n      if (element) {\n        observer.disconnect();\n        resolve(element);\n      } else if (Date.now() - startTime > timeout) {\n        observer.disconnect();\n        resolve(null);\n      }\n    });\n    \n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    // Timeout fallback\n    setTimeout(() => {\n      observer.disconnect();\n      resolve(null);\n    }, timeout);\n  });\n}\n\n/**\n * Aguarda tempo especificado\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Limpa cache do navegador e recarrega a página\n */\nasync function clearCacheAndReload(): Promise<void> {\n  try {\n    // Limpa localStorage\n    if (window.localStorage) {\n      window.localStorage.clear();\n    }\n    \n    // Limpa sessionStorage\n    if (window.sessionStorage) {\n      window.sessionStorage.clear();\n    }\n    \n    // Limpa cookies do domínio atual\n    if (document.cookie) {\n      document.cookie.split(\";\").forEach((c) => {\n        document.cookie = c.replace(/^ +/, \"\").replace(/=.*/, \"=;expires=\" + new Date().toUTCString() + \";path=/\");\n      });\n    }\n    \n    // Força recarga sem cache\n    window.location.reload();\n    \n    // Aguarda a página recarregar\n    await new Promise(resolve => {\n      window.addEventListener('load', () => resolve(void 0));\n    });\n  } catch (error) {\n    console.error('Erro ao limpar cache:', error);\n  }\n}\n\n/**\n * Função principal do runner - executada no contexto da página\n */\nasync function runReplay(message: ReplayExecute): Promise<void> {\n  const { actions, initialUrl, mode } = message;\n  let completedSteps = 0;\n  \n  try {\n    // Se modo clean-cache, limpa cache e recarrega primeiro\n    if (mode === ReplayMode.CLEAN_CACHE && window.location.href === initialUrl) {\n      await clearCacheAndReload();\n      // Após reload, não precisa continuar pois a página foi recarregada\n      // O script será reinjetado e continuará a partir daqui\n      return;\n    }\n    \n    // Navega para URL inicial se diferente\n    if (window.location.href !== initialUrl) {\n      await executeNavigate(initialUrl);\n      // Aguarda página carregar completamente\n      await new Promise(resolve => {\n        if (document.readyState === 'complete') {\n          resolve(void 0);\n        } else {\n          window.addEventListener('load', () => resolve(void 0));\n        }\n      });\n      \n      // Se modo clean-cache e acabou de navegar, limpa cache e recarrega\n      if (mode === ReplayMode.CLEAN_CACHE) {\n        await clearCacheAndReload();\n        return;\n      }\n    }\n    \n    // Executa cada ação respeitando delays\n    for (let i = 0; i < actions.length; i++) {\n      const action = actions[i];\n      const nextAction = actions[i + 1];\n      \n      // Calcula delay até próxima ação\n      const delay = nextAction \n        ? nextAction.timestamp - action.timestamp \n        : 500; // Delay padrão para última ação\n      \n      // Executa ação baseada no tipo\n      let result: ActionExecutionResult;\n      \n      // Get the first available selector\n      const selector = action.selectors ? Object.values(action.selectors).find(s => s !== null) || '' : '';\n      \n      switch (action.type) {\n        case ActionType.Click:\n          result = await executeClick(selector, {});\n          break;\n          \n        case ActionType.Input:\n          result = await executeType(selector, action.value || '', {});\n          break;\n          \n        case ActionType.Navigate:\n          const navAction = action as any; // Type assertion for NavigateAction\n          result = await executeNavigate(navAction.url || '');\n          break;\n          \n        default:\n          result = { success: false, error: `Tipo de ação não suportado: ${action.type}` };\n      }\n      \n      if (!result.success) {\n        throw new Error(`Falha na ação ${i + 1}: ${result.error}`);\n      }\n      \n      completedSteps++;\n      \n      // Aguarda delay natural entre ações\n      await sleep(Math.min(delay, 3000)); // Máximo 3 segundos entre ações\n    }\n    \n    // Envia resultado de sucesso\n    chrome.runtime.sendMessage<ReplayResult>({\n      type: 'REPLAY_RESULT',\n      success: true,\n      completedSteps\n    });\n    \n  } catch (error) {\n    // Envia resultado de erro\n    chrome.runtime.sendMessage<ReplayResult>({\n      type: 'REPLAY_RESULT',\n      success: false,\n      error: error instanceof Error ? error.message : 'Erro desconhecido',\n      completedSteps\n    });\n  }\n}\n\n// Listener para mensagens do background\nchrome.runtime.onMessage.addListener((message: any) => {\n  if (message.type === 'REPLAY_EXECUTE') {\n    runReplay(message as ReplayExecute);\n  }\n});\n\n// Exporta para testes\nexport { executeClick, executeType, executeNavigate, waitForElement };",
    "processedAt": "2025-07-21T04:25:10.433Z"
  },
  {
    "path": "src/modules/replay/replay-handler.ts",
    "sha": "5d36e475b7b6a70aee336a49b32b3fbdd725e20c",
    "size": 5895,
    "summary": "O ReplayHandler é um componente singleton responsável por gerenciar a execução de replays de gravações de ações do usuário em abas do navegador, coordenando a comunicação entre o popup e o runner. Ele controla a criação e monitoramento das abas, injeta scripts para executar as ações gravadas, atualiza o estado do replay em tempo real e trata resultados, garantindo sincronização e limpeza do estado após a conclusão. Essa funcionalidade habilita a automação e reprodução confiável de fluxos de usuário para testes ou demonstrações, integrando-se ao armazenamento de gravações e ao sistema de mensagens do Chrome.",
    "content": "/**\n * ReplayHandler - Gerencia comunicação entre popup e runner para execução de replay\n * Coordena abertura de nova aba, injeção de script e monitoramento de status\n */\n\nimport type { ReplayRequest, ReplayState, ReplayStatusUpdate, ReplayExecute, ReplayResult } from '../../types/replay';\nimport type { RecordingEntry } from '../../pages/types/recording';\nimport { recordingStore } from '../../pages/storage/recording-store';\n\nclass ReplayHandler {\n  private static instance: ReplayHandler;\n  private replayTabs: Map<number, ReplayState>;\n  \n  private constructor() {\n    this.replayTabs = new Map();\n    this.setupMessageListeners();\n  }\n  \n  /**\n   * Obtém instância singleton do ReplayHandler\n   */\n  static getInstance(): ReplayHandler {\n    if (!ReplayHandler.instance) {\n      ReplayHandler.instance = new ReplayHandler();\n    }\n    return ReplayHandler.instance;\n  }\n  \n  /**\n   * Configura listeners para mensagens\n   */\n  private setupMessageListeners(): void {\n    chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {\n      if (message.type === 'REPLAY_REQUEST') {\n        this.handleReplayRequest(message as ReplayRequest, sendResponse);\n        return true; // Indica resposta assíncrona\n      }\n      \n      if (message.type === 'REPLAY_RESULT' && sender.tab?.id) {\n        this.handleReplayResult(message as ReplayResult, sender.tab.id);\n      }\n    });\n    \n    // Limpa estado quando aba é fechada\n    chrome.tabs.onRemoved.addListener((tabId) => {\n      if (this.replayTabs.has(tabId)) {\n        this.replayTabs.delete(tabId);\n        this.broadcastStatusUpdate(tabId, {\n          status: 'idle',\n          currentStepIndex: 0,\n          totalSteps: 0,\n          startTime: null\n        });\n      }\n    });\n  }\n  \n  /**\n   * Processa requisição de replay\n   */\n  private async handleReplayRequest(\n    request: ReplayRequest, \n    sendResponse: (response: any) => void\n  ): Promise<void> {\n    try {\n      // Busca gravação no storage\n      const recording = await recordingStore.get(request.recordingId);\n      \n      if (!recording) {\n        sendResponse({ success: false, error: 'Gravação não encontrada' });\n        return;\n      }\n      \n      // Cria nova aba\n      const tab = await chrome.tabs.create({\n        url: recording.url,\n        active: true\n      });\n      \n      if (!tab.id) {\n        sendResponse({ success: false, error: 'Falha ao criar aba' });\n        return;\n      }\n      \n      // Inicializa estado do replay\n      const state: ReplayState = {\n        status: 'preparing',\n        currentStepIndex: 0,\n        totalSteps: recording.actions.length,\n        startTime: Date.now()\n      };\n      \n      this.replayTabs.set(tab.id, state);\n      \n      // Aguarda aba carregar\n      const listener = (tabId: number, changeInfo: chrome.tabs.TabChangeInfo) => {\n        if (tabId === tab.id && changeInfo.status === 'complete') {\n          chrome.tabs.onUpdated.removeListener(listener);\n          \n          // Injeta script do runner\n          chrome.scripting.executeScript({\n            target: { tabId: tab.id! },\n            files: ['replayRunner.bundle.js']\n          }).then(() => {\n            // Envia ações para execução\n            const executeMessage: ReplayExecute = {\n              type: 'REPLAY_EXECUTE',\n              actions: recording.actions,\n              initialUrl: recording.url,\n              mode: request.mode\n            };\n            \n            chrome.tabs.sendMessage(tab.id!, executeMessage);\n            \n            // Atualiza status para running\n            const runningState: ReplayState = {\n              ...state,\n              status: 'running'\n            };\n            \n            if (tab.id) {\n              this.replayTabs.set(tab.id, runningState);\n              this.broadcastStatusUpdate(tab.id, runningState);\n            }\n          }).catch((error) => {\n            sendResponse({ success: false, error: `Falha ao injetar script: ${error.message}` });\n          });\n        }\n      };\n      \n      chrome.tabs.onUpdated.addListener(listener);\n      \n      sendResponse({ success: true, tabId: tab.id });\n      \n    } catch (error) {\n      sendResponse({ \n        success: false, \n        error: error instanceof Error ? error.message : 'Erro desconhecido' \n      });\n    }\n  }\n  \n  /**\n   * Processa resultado do replay\n   */\n  private handleReplayResult(result: ReplayResult, tabId: number): void {\n    const state = this.replayTabs.get(tabId);\n    \n    if (!state) return;\n    \n    const updatedState: ReplayState = {\n      ...state,\n      status: result.success ? 'completed' : 'error',\n      currentStepIndex: result.completedSteps || 0,\n      error: result.error\n    };\n    \n    this.replayTabs.set(tabId, updatedState);\n    this.broadcastStatusUpdate(tabId, updatedState);\n    \n    // Remove estado após 5 segundos se completado\n    if (result.success) {\n      setTimeout(() => {\n        this.replayTabs.delete(tabId);\n      }, 5000);\n    }\n  }\n  \n  /**\n   * Envia atualização de status para todos os listeners\n   */\n  private broadcastStatusUpdate(tabId: number, state: ReplayState): void {\n    const update: ReplayStatusUpdate = {\n      type: 'REPLAY_STATUS',\n      state,\n      tabId\n    };\n    \n    // Envia para popup\n    try {\n      chrome.runtime.sendMessage(update);\n    } catch {\n      // Ignora erro se popup não estiver aberto\n    }\n  }\n  \n  /**\n   * Obtém estado atual do replay para uma aba\n   */\n  getReplayState(tabId: number): ReplayState | null {\n    return this.replayTabs.get(tabId) || null;\n  }\n  \n  /**\n   * Para replay em execução\n   */\n  stopReplay(tabId: number): void {\n    if (this.replayTabs.has(tabId)) {\n      chrome.tabs.remove(tabId).catch(() => {\n        // Ignora erro se aba já foi fechada\n      });\n    }\n  }\n}\n\n// Exporta instância singleton\nexport const replayHandler = ReplayHandler.getInstance();",
    "processedAt": "2025-07-21T04:25:10.714Z"
  },
  {
    "path": "src/pages/Popup/components/RecordingHistory.tsx",
    "sha": "e8668356f89bda2aea9e276ea75e8ea821a98ae0",
    "size": 17753,
    "summary": "O componente RecordingHistory é uma interface React que gerencia e exibe um histórico de gravações de sessões, permitindo busca, ordenação, seleção múltipla, exclusão, exportação e importação de dados. Ele mantém estados internos para controlar carregamento, filtros, seleção e notificações, além de interagir com um serviço externo RecordingService para persistência e manipulação dos dados. A interface apresenta uma tabela dinâmica com colunas ordenáveis, suporte a seleção em massa e feedback visual, garantindo uma experiência fluida e responsiva para o usuário final.",
    "content": "/**\n * Componente para exibir o histórico de gravações com tabela moderna e busca\n */\n\nimport React, { useEffect, useState, useMemo, useCallback } from 'react';\nimport { RecordingEntry } from '../../types/recording';\nimport { RecordingService } from '../../storage/recording-service';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport {\n  faHistory,\n  faSearch,\n  faTrash,\n  faChevronLeft,\n  faClock,\n  faGlobe,\n  faPlay,\n  faCalendarAlt,\n  faTasks,\n  faSpinner,\n} from '@fortawesome/free-solid-svg-icons';\nimport { truncateText, truncateUrl } from '../../Common/utils/text';\nimport '../themes/dark-core.css';\nimport './recording-history.css';\n\ninterface RecordingHistoryProps {\n  onSelectRecording: (recording: RecordingEntry) => void;\n  onBack: () => void;\n}\n\ntype SortField = 'title' | 'startedAt' | 'actions';\ntype SortDirection = 'asc' | 'desc';\n\ninterface SortConfig {\n  field: SortField;\n  direction: SortDirection;\n}\n\n/**\n * Componente de histórico de gravações\n */\nexport const RecordingHistory: React.FC<RecordingHistoryProps> = ({\n  onSelectRecording,\n  onBack,\n}) => {\n  const [recordings, setRecordings] = useState<RecordingEntry[]>([]);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [loading, setLoading] = useState(true);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [sortConfig, setSortConfig] = useState<SortConfig>({\n    field: 'startedAt',\n    direction: 'desc',\n  });\n  const [notification, setNotification] = useState<{\n    type: 'success' | 'error';\n    message: string;\n  } | null>(null);\n\n  // Carrega as gravações ao montar o componente\n  useEffect(() => {\n    loadRecordings();\n  }, []);\n\n  const loadRecordings = async () => {\n    try {\n      console.log('🚀 [RecordingHistory] Carregando gravações...');\n      setLoading(true);\n      const data = await RecordingService.listRecordings();\n      console.log(\n        `✅ [RecordingHistory] ${data.length} gravações carregadas com sucesso`\n      );\n      setRecordings(data);\n    } catch (error) {\n      console.error('❌ [RecordingHistory] Erro ao carregar gravações:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Filtra e ordena gravações\n  const processedRecordings = useMemo(() => {\n    let filtered = recordings;\n\n    // Aplicar filtro de busca\n    if (searchTerm.trim()) {\n      const term = searchTerm.toLowerCase();\n      filtered = recordings.filter(\n        (recording) =>\n          recording.title.toLowerCase().includes(term) ||\n          recording.hostname.toLowerCase().includes(term) ||\n          recording.url.toLowerCase().includes(term)\n      );\n    }\n\n    // Aplicar ordenação\n    const sorted = [...filtered].sort((a, b) => {\n      const { field, direction } = sortConfig;\n      let aValue: any = a[field];\n      let bValue: any = b[field];\n\n      if (field === 'actions') {\n        aValue = a.actions.length;\n        bValue = b.actions.length;\n      }\n\n      if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n      if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      return 0;\n    });\n\n    return sorted;\n  }, [recordings, searchTerm, sortConfig]);\n\n  const handleSort = useCallback((field: SortField) => {\n    setSortConfig((current) => ({\n      field,\n      direction:\n        current.field === field && current.direction === 'asc' ? 'desc' : 'asc',\n    }));\n  }, []);\n\n  const handleDelete = async (id: string, e: React.MouseEvent) => {\n    e.stopPropagation();\n\n    if (confirm('Tem certeza que deseja excluir esta gravação?')) {\n      try {\n        console.log(`🗑️ [RecordingHistory] Excluindo gravação: ${id}`);\n        await RecordingService.removeRecording(id);\n        console.log('✅ [RecordingHistory] Gravação excluída com sucesso');\n        setSelectedIds((prev) => {\n          const newSet = new Set(prev);\n          newSet.delete(id);\n          return newSet;\n        });\n        await loadRecordings();\n      } catch (error) {\n        console.error('❌ [RecordingHistory] Erro ao excluir gravação:', error);\n      }\n    }\n  };\n\n  const toggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const newSet = new Set(prev);\n      if (newSet.has(id)) {\n        newSet.delete(id);\n      } else {\n        newSet.add(id);\n      }\n      return newSet;\n    });\n  }, []);\n\n  const toggleSelectAll = useCallback(() => {\n    if (\n      selectedIds.size === processedRecordings.length &&\n      processedRecordings.length > 0\n    ) {\n      setSelectedIds(new Set());\n    } else {\n      setSelectedIds(new Set(processedRecordings.map((r) => r.id)));\n    }\n  }, [selectedIds, processedRecordings]);\n\n  // Auto-hide notification after 5 seconds\n  useEffect(() => {\n    if (notification) {\n      const timer = setTimeout(() => {\n        setNotification(null);\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [notification]);\n\n  // Callback para sucesso na exportação\n  const handleExportSuccess = useCallback((count: number) => {\n    setNotification({\n      type: 'success',\n      message: `✅ ${count} gravação(ões) exportada(s) com sucesso!`,\n    });\n    setSelectedIds(new Set()); // Clear selection after export\n  }, []);\n\n  // Callback para erro na exportação\n  const handleExportError = useCallback((error: string) => {\n    setNotification({\n      type: 'error',\n      message: `❌ Erro na exportação: ${error}`,\n    });\n  }, []);\n\n  // Callback para sucesso na importação\n  const handleImportSuccess = useCallback(async (importedIds: string[]) => {\n    setNotification({\n      type: 'success',\n      message: `✅ ${importedIds.length} gravação(ões) importada(s) com sucesso!`,\n    });\n\n    // Recarrega a lista de gravações\n    await loadRecordings();\n  }, []);\n\n  // Callback para erro na importação\n  const handleImportError = useCallback((error: string) => {\n    setNotification({\n      type: 'error',\n      message: `❌ Erro na importação: ${error}`,\n    });\n  }, []);\n\n  const formatDuration = (start: number, end: number): string => {\n    const duration = end - start;\n    const seconds = Math.floor(duration / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n\n    if (minutes > 0) {\n      return `${minutes}m ${remainingSeconds}s`;\n    }\n    return `${seconds}s`;\n  };\n\n  const formatDate = (timestamp: number): string => {\n    const date = new Date(timestamp);\n    const today = new Date();\n    const yesterday = new Date(today);\n    yesterday.setDate(yesterday.getDate() - 1);\n\n    if (date.toDateString() === today.toDateString()) {\n      return `Hoje ${date.toLocaleTimeString('pt-BR', {\n        hour: '2-digit',\n        minute: '2-digit',\n      })}`;\n    } else if (date.toDateString() === yesterday.toDateString()) {\n      return `Ontem ${date.toLocaleTimeString('pt-BR', {\n        hour: '2-digit',\n        minute: '2-digit',\n      })}`;\n    }\n\n    return date.toLocaleDateString('pt-BR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  const handleRowClick = useCallback(\n    (recording: RecordingEntry) => {\n      onSelectRecording(recording);\n    },\n    [onSelectRecording]\n  );\n\n  return (\n    <div className=\"ds-dark recording-history\">\n      {/* Header */}\n      <div className=\"recording-history-header\">\n        <h2 className=\"recording-history-title\">\n          <FontAwesomeIcon icon={faHistory} />\n          Histórico de Gravações\n        </h2>\n\n        <div className=\"recording-history-header-actions\">\n          {' '}\n          {/* Export/Import buttons */}\n          <div className=\"recording-history-bulk-actions\">\n            {/* Export Button */}\n            <button\n              className=\"download-json-button\"\n              onClick={async () => {\n                if (selectedIds.size === 0) return;\n\n                try {\n                  console.log('🚀 Iniciando exportação...');\n                  const exportData = await RecordingService.exportMany(\n                    Array.from(selectedIds)\n                  );\n\n                  // Download JSON\n                  const blob = new Blob([exportData], {\n                    type: 'application/json',\n                  });\n                  const url = URL.createObjectURL(blob);\n                  const link = document.createElement('a');\n                  link.href = url;\n                  link.download = `recordings_${new Date()\n                    .toISOString()\n                    .replace(/[:.]/g, '-')\n                    .slice(0, -5)}.json`;\n                  document.body.appendChild(link);\n                  link.click();\n                  document.body.removeChild(link);\n                  URL.revokeObjectURL(url);\n\n                  handleExportSuccess(selectedIds.size);\n                } catch (error) {\n                  handleExportError(\n                    error instanceof Error ? error.message : 'Erro desconhecido'\n                  );\n                }\n              }}\n              disabled={selectedIds.size === 0}\n              title={\n                selectedIds.size === 0\n                  ? 'Selecione gravações para exportar'\n                  : `Exportar ${selectedIds.size} gravação(ões)`\n              }\n            >\n              📥 Exportar ({selectedIds.size})\n            </button>\n\n            {/* Import Button */}\n            <button\n              className=\"import-json-button\"\n              onClick={() => {\n                const input = document.createElement('input');\n                input.type = 'file';\n                input.accept = '.json';\n                input.onchange = async (e) => {\n                  const file = (e.target as HTMLInputElement).files?.[0];\n                  if (!file) return;\n\n                  try {\n                    const content = await file.text();\n                    const importedIds = await RecordingService.importMany(\n                      content\n                    );\n                    handleImportSuccess(importedIds);\n                  } catch (error) {\n                    handleImportError(\n                      error instanceof Error\n                        ? error.message\n                        : 'Erro desconhecido'\n                    );\n                  }\n                };\n                input.click();\n              }}\n              title=\"Importar gravações de arquivo JSON\"\n            >\n              📤 Importar\n            </button>\n          </div>\n          <button className=\"recording-btn recording-btn-back\" onClick={onBack}>\n            <FontAwesomeIcon icon={faChevronLeft} />\n            Voltar\n          </button>\n        </div>\n      </div>\n\n      {/* Notification */}\n      {notification && (\n        <div className={`recording-history-notification ${notification.type}`}>\n          {notification.message}\n        </div>\n      )}\n\n      {/* Content */}\n      <div className=\"recording-history-content\">\n        {/* Toolbar */}\n        <div className=\"recording-history-toolbar\">\n          <div className=\"recording-history-search\">\n            <FontAwesomeIcon\n              icon={faSearch}\n              className=\"recording-history-search-icon\"\n            />\n            <input\n              type=\"text\"\n              className=\"recording-history-search-input\"\n              placeholder=\"Buscar por site ou URL...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              style={{\n                paddingLeft: '32px',\n              }}\n            />\n          </div>\n\n          {selectedIds.size > 0 && (\n            <div className=\"recording-history-selection-info\">\n              <span>{selectedIds.size} selecionado(s)</span>\n            </div>\n          )}\n        </div>\n\n        {/* Table Container */}\n        <div className=\"recording-history-table-container\">\n          {loading ? (\n            <div className=\"recording-history-loading\">\n              <FontAwesomeIcon\n                icon={faSpinner}\n                className=\"recording-history-loading-icon\"\n              />\n              <span>Carregando gravações...</span>\n            </div>\n          ) : processedRecordings.length === 0 ? (\n            <div className=\"recording-history-empty\">\n              <div className=\"recording-history-empty-icon\">\n                {searchTerm ? '🔍' : '📝'}\n              </div>\n              <div className=\"recording-history-empty-text\">\n                {searchTerm\n                  ? 'Nenhuma gravação encontrada para esta busca.'\n                  : 'Nenhuma gravação salva ainda.'}\n              </div>\n              {searchTerm && (\n                <div className=\"recording-history-empty-hint\">\n                  Tente buscar com outros termos\n                </div>\n              )}\n            </div>\n          ) : (\n            <table className=\"recording-history-table\">\n              <thead>\n                <tr>\n                  <th style={{ width: '40px' }}>\n                    <input\n                      type=\"checkbox\"\n                      className=\"recording-checkbox\"\n                      checked={\n                        selectedIds.size === processedRecordings.length &&\n                        processedRecordings.length > 0\n                      }\n                      onChange={toggleSelectAll}\n                    />\n                  </th>\n                  <th className=\"sortable\" onClick={() => handleSort('title')}>\n                    <div className=\"header-content\">\n                      <FontAwesomeIcon icon={faGlobe} />\n                      <span>Gravação</span>\n                      {sortConfig.field === 'title' && (\n                        <span className=\"sort-indicator\">\n                          {sortConfig.direction === 'asc' ? '↑' : '↓'}\n                        </span>\n                      )}\n                    </div>\n                  </th>\n                  <th\n                    className=\"sortable\"\n                    onClick={() => handleSort('startedAt')}\n                  >\n                    <div className=\"header-content\">\n                      <FontAwesomeIcon icon={faCalendarAlt} />\n                      <span>Data</span>\n                      {sortConfig.field === 'startedAt' && (\n                        <span className=\"sort-indicator\">\n                          {sortConfig.direction === 'asc' ? '↑' : '↓'}\n                        </span>\n                      )}\n                    </div>\n                  </th>\n                  <th>\n                    <div className=\"header-content\">\n                      <FontAwesomeIcon icon={faClock} />\n                      <span>Duração</span>\n                    </div>\n                  </th>\n                  <th\n                    className=\"sortable\"\n                    onClick={() => handleSort('actions')}\n                  >\n                    <div className=\"header-content\">\n                      <FontAwesomeIcon icon={faTasks} />\n                      <span>Ações</span>\n                      {sortConfig.field === 'actions' && (\n                        <span className=\"sort-indicator\">\n                          {sortConfig.direction === 'asc' ? '↑' : '↓'}\n                        </span>\n                      )}\n                    </div>\n                  </th>\n                  <th style={{ width: '60px' }}></th>\n                </tr>\n              </thead>\n              <tbody>\n                {processedRecordings.map((recording) => (\n                  <tr\n                    key={recording.id}\n                    className={selectedIds.has(recording.id) ? 'selected' : ''}\n                    onClick={() => handleRowClick(recording)}\n                  >\n                    <td onClick={(e) => e.stopPropagation()}>\n                      <input\n                        type=\"checkbox\"\n                        className=\"recording-checkbox\"\n                        checked={selectedIds.has(recording.id)}\n                        onChange={() => toggleSelection(recording.id)}\n                      />\n                    </td>\n                    <td>\n                      <div className=\"recording-info\">\n                        <div className=\"recording-title\">\n                          {truncateText(recording.title, 35)}\n                        </div>\n                        <div className=\"recording-url\">\n                          {truncateUrl(recording.url, 40)}\n                        </div>\n                      </div>\n                    </td>\n                    <td>\n                      <span className=\"recording-date\">\n                        {formatDate(recording.startedAt)}\n                      </span>\n                    </td>\n                    <td>\n                      <span className=\"recording-duration\">\n                        {formatDuration(recording.startedAt, recording.endedAt)}\n                      </span>\n                    </td>\n                    <td>\n                      <span className=\"recording-actions-badge\">\n                        {recording.actions.length}\n                      </span>\n                    </td>\n                    <td>\n                      <button\n                        className=\"recording-delete-btn\"\n                        onClick={(e) => handleDelete(recording.id, e)}\n                        title=\"Excluir gravação\"\n                      >\n                        <FontAwesomeIcon icon={faTrash} />\n                      </button>\n                    </td>\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n",
    "processedAt": "2025-07-21T04:25:12.605Z"
  },
  {
    "path": "src/hooks/use-replay.ts",
    "sha": "6198a71f1be47f941657c109da68e94725496f9b",
    "size": 4231,
    "summary": "Este código implementa um React hook customizado chamado useReplay, que gerencia o estado e a lógica para controlar a funcionalidade de replay de gravações em um ambiente de extensão Chrome. Ele coordena a comunicação assíncrona com o background script via mensagens, atualiza o estado interno conforme o progresso do replay, e gerencia a abertura e fechamento da aba onde o replay ocorre. O hook oferece métodos para iniciar e parar o replay, além de controlar erros e estados intermediários, garantindo uma experiência de usuário fluida e consistente durante o processo de replay.",
    "content": "/**\n * Hook React para gerenciar funcionalidade de replay no popup\n * Coordena comunicação com background script e atualização de UI\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport type { ReplayState, ReplayRequest, ReplayStatusUpdate, ReplayMode } from '../types/replay.js';\n\ninterface UseReplayResult {\n  replayState: ReplayState | null;\n  isReplaying: boolean;\n  replayTabId: number | null;\n  startReplay: (recordingId: string, mode?: ReplayMode) => Promise<void>;\n  stopReplay: () => void;\n  error: string | null;\n}\n\nconst initialState: ReplayState = {\n  status: 'idle',\n  currentStepIndex: 0,\n  totalSteps: 0,\n  startTime: null\n};\n\n/**\n * Hook para gerenciar replay de gravações\n */\nexport function useReplay(): UseReplayResult {\n  const [replayState, setReplayState] = useState<ReplayState | null>(null);\n  const [replayTabId, setReplayTabId] = useState<number | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Configura listener para atualizações de status\n  useEffect(() => {\n    const handleMessage = (message: any) => {\n      if (message.type === 'REPLAY_STATUS') {\n        const statusUpdate = message as ReplayStatusUpdate;\n        \n        // Atualiza estado apenas se for da aba atual\n        if (replayTabId === null || statusUpdate.tabId === replayTabId) {\n          setReplayState(statusUpdate.state);\n          \n          // Limpa erro se status mudou para sucesso\n          if (statusUpdate.state.status === 'completed') {\n            setError(null);\n          }\n          \n          // Define erro se status mudou para erro\n          if (statusUpdate.state.status === 'error' && statusUpdate.state.error) {\n            setError(statusUpdate.state.error);\n          }\n        }\n      }\n    };\n    \n    chrome.runtime.onMessage.addListener(handleMessage);\n    \n    return () => {\n      chrome.runtime.onMessage.removeListener(handleMessage);\n    };\n  }, [replayTabId]);\n  \n  // Limpa estado quando aba é fechada\n  useEffect(() => {\n    if (!replayTabId) return;\n    \n    const handleTabRemoved = (tabId: number) => {\n      if (tabId === replayTabId) {\n        setReplayState(null);\n        setReplayTabId(null);\n        setError(null);\n      }\n    };\n    \n    chrome.tabs.onRemoved.addListener(handleTabRemoved);\n    \n    return () => {\n      chrome.tabs.onRemoved.removeListener(handleTabRemoved);\n    };\n  }, [replayTabId]);\n  \n  /**\n   * Inicia replay de uma gravação\n   */\n  const startReplay = useCallback(async (recordingId: string, mode?: ReplayMode): Promise<void> => {\n    try {\n      setError(null);\n      setReplayState({\n        ...initialState,\n        status: 'preparing'\n      });\n      \n      // Envia requisição para background\n      const request: ReplayRequest = {\n        type: 'REPLAY_REQUEST',\n        recordingId,\n        mode\n      };\n      \n      const response = await chrome.runtime.sendMessage(request) as { success: boolean; error?: string; tabId?: number } | undefined;\n      \n      if (!response || !response.success) {\n        throw new Error(response?.error || 'Falha ao iniciar replay');\n      }\n      \n      // Armazena ID da aba\n      if (response.tabId !== undefined) {\n        setReplayTabId(response.tabId);\n      }\n      \n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erro desconhecido';\n      setError(errorMessage);\n      setReplayState({\n        ...initialState,\n        status: 'error',\n        error: errorMessage\n      });\n      throw err;\n    }\n  }, []);\n  \n  /**\n   * Para replay em execução\n   */\n  const stopReplay = useCallback((): void => {\n    if (replayTabId) {\n      // Fecha aba do replay\n      chrome.tabs.remove(replayTabId).catch(() => {\n        // Ignora erro se aba já foi fechada\n      });\n      \n      // Limpa estado\n      setReplayState(null);\n      setReplayTabId(null);\n      setError(null);\n    }\n  }, [replayTabId]);\n  \n  // Calcula se está em replay ativo\n  const isReplaying = replayState !== null && \n    replayState.status !== 'idle' && \n    replayState.status !== 'completed' &&\n    replayState.status !== 'error';\n  \n  return {\n    replayState,\n    isReplaying,\n    replayTabId,\n    startReplay,\n    stopReplay,\n    error\n  };\n}",
    "processedAt": "2025-07-21T04:25:13.211Z"
  },
  {
    "path": "src/pages/Common/utils.ts",
    "sha": "7f8d95ed218079fc0a821960044866361df1d513",
    "size": 4643,
    "summary": "Este código implementa funcionalidades para gerenciar o estado de gravação e preferências do usuário em uma extensão de navegador, utilizando a API de armazenamento local do Chrome. Ele oferece métodos para iniciar e finalizar gravações, armazenar preferências como biblioteca e posição da barra, além de funções assíncronas para manipulação de abas, execução de scripts e identificação de contextos específicos como testes Cypress. O comportamento central envolve a persistência e recuperação de dados no armazenamento local, controle do fluxo de gravação e integração com APIs do navegador para manipulação de abas e execução de scripts, garantindo uma experiência consistente e configurável para o usuário. A arquitetura suporta compatibilidade entre manifest v2 e v3, e inclui tratamento de erros e limpeza de contexto, promovendo robustez e manutenção eficiente do estado da aplicação.",
    "content": "export function setEndRecordingStorage() {\n  chrome.storage.local.set({\n    recordingState: 'finished',\n    recordingTabId: null,\n    recordingFrameId: null,\n    returnTabId: null,\n    firstUrl: null, // Limpa a primeira URL capturada\n  });\n}\n\nexport function setPreferredLibraryStorage(library: string) {\n  chrome.storage.local.set({ preferredLibrary: library });\n}\n\nexport function setPreferredBarPositionStorage(position: string) {\n  chrome.storage.local.set({ preferredBarPosition: position });\n}\n\nexport function setStartRecordingStorage(\n  tabId: number,\n  frameId: number,\n  newUrl: string,\n  returnTabId?: number\n) {\n  const storage = {\n    recordingState: 'active',\n    recordingTabId: tabId,\n    recordingFrameId: frameId,\n    recordingStartTime: Date.now(),\n    firstUrl: newUrl, // Salva a URL inicial quando a gravação começa\n    recording: [\n      {\n        type: 'load',\n        url: newUrl,\n      },\n    ],\n    ...(returnTabId != null\n      ? {\n          returnTabId,\n        }\n      : {}),\n  };\n  chrome.storage.local.set(storage);\n}\n\nexport async function createTab(url: string) {\n  // This is because we're straddling v2 and v3 manifest\n  const api = typeof browser === 'object' ? browser : chrome;\n\n  const tab = await api.tabs.create({\n    url,\n  });\n\n  return tab;\n}\n\nexport function localStorageGet(keys: string[]) {\n  return new Promise<{ [key: string]: any }>((resolve, reject) => {\n    chrome.storage.local.get(keys, (storage) => {\n      resolve(storage);\n    });\n  });\n}\n\nexport function localStorageSet(items: { [key: string]: any }) {\n  return new Promise<void>((resolve, reject) => {\n    chrome.storage.local.set(items, () => {\n      if (chrome.runtime.lastError) {\n        reject(chrome.runtime.lastError);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexport async function getRandomInstallId() {\n  return localStorageGet(['randomId']).then(({ randomId }) => {\n    let id = randomId;\n    if (randomId == null) {\n      id = `${Math.floor(Math.random() * 1000000)}`;\n      chrome.storage.local.set({ randomId: id });\n    }\n\n    return id;\n  });\n}\n\nexport async function getCurrentTab(): Promise<chrome.tabs.Tab> {\n  // This is because we're straddling v2 and v3 manifest\n  const api = typeof browser === 'object' ? browser : chrome;\n\n  const [tab] = await api.tabs.query({\n    active: true,\n    currentWindow: true,\n  });\n\n  return tab;\n}\n\n// Determins if the current tab is a Cypress test tab\nexport function isCypressBrowser(tabId: number) {\n  if (typeof browser === 'object') {\n    return browser.tabs\n      .executeScript(tabId, {\n        code: `document.querySelector('script[src*=\"/__cypress\"]') != null`,\n      })\n      .then((result) => (result?.[0] ?? false) as boolean);\n  } else {\n    return new Promise((resolve, reject) => {\n      chrome.scripting.executeScript(\n        {\n          target: { tabId },\n          func: () =>\n            document.querySelector('script[src*=\"/__cypress\"]') != null,\n        },\n        (executedScript) => resolve(executedScript?.[0]?.result ?? false)\n      );\n    });\n  }\n}\n\nexport function getCypressAutFrame(tabId: number) {\n  return new Promise<chrome.webNavigation.GetAllFrameResultDetails>(\n    (resolve, reject) => {\n      chrome.webNavigation.getAllFrames({ tabId }, (frames) => {\n        const autFrame = frames?.filter((frame) => {\n          // Must be child of parent frame and not have \"__cypress\" in the url\n          return (\n            frame.parentFrameId === 0 && frame.url.indexOf('__cypress') === -1\n          );\n        })?.[0];\n        if (autFrame == null || autFrame.frameId == null) {\n          return reject(new Error('No AUT frame found'));\n        }\n        resolve(autFrame);\n      });\n    }\n  );\n}\n\nexport async function executeScript(\n  tabId: number,\n  frameId: number,\n  file: string\n) {\n  if (typeof browser === 'object') {\n    await browser.tabs.executeScript(tabId, { file, frameId });\n  } else {\n    await chrome.scripting.executeScript({\n      target: { tabId, frameIds: [frameId] },\n      files: [file],\n    });\n  }\n}\n\nexport async function executeCleanUp(tabId: number, frameId: number) {\n  if (typeof browser === 'object') {\n    await browser.tabs.executeScript(tabId, {\n      frameId,\n      code: `\n        if (typeof window?.[REDACTED] === 'function') {\n          window.[REDACTED]();\n        }\n      `,\n    });\n  } else {\n    await chrome.scripting.executeScript({\n      target: { tabId, frameIds: [frameId] },\n      func: () => {\n        if (typeof window?.[REDACTED] === 'function') {\n          window.[REDACTED]();\n        }\n      },\n    });\n  }\n}\n",
    "processedAt": "2025-07-21T04:25:13.572Z"
  },
  {
    "path": "src/pages/types/recording.ts",
    "sha": "81a987df138c8d34b0497ea3eeb284582997a639",
    "size": 1452,
    "summary": "O código define interfaces TypeScript para um sistema de histórico de gravações focado em capturar, armazenar e gerenciar sessões de gravação de ações de usuário em páginas web. Ele estrutura dados detalhados como identificadores únicos, timestamps, URLs, ações gravadas e código gerado para testes automatizados com Cypress, além de configurar políticas para gerenciamento do histórico, como limite máximo de entradas e estratégias de poda. A interface backend padroniza operações assíncronas para salvar, listar, recuperar, remover e limpar gravações, garantindo integração consistente e controle sobre o ciclo de vida dos dados de gravação.",
    "content": "/**\n * Tipos para o sistema de histórico de gravações\n */\n\nimport { Action } from './index';\n\n/**\n * Representa uma entrada no histórico de gravações\n */\nexport interface RecordingEntry {\n  /** ID único da gravação no formato: {hostname}:{yyyy-MM-dd_HH-mm} */\n  id: string;\n  \n  /** Título formatado da gravação (hostname + data/hora) */\n  title: string;\n  \n  /** URL da página onde a gravação foi feita */\n  url: string;\n  \n  /** Primeira URL capturada durante a gravação (opcional por compatibilidade) */\n  firstUrl?: string;\n  \n  /** Hostname extraído da URL */\n  hostname: string;\n  \n  /** Timestamp do início da gravação */\n  startedAt: number;\n  \n  /** Timestamp do fim da gravação */\n  endedAt: number;\n  \n  /** Lista de ações gravadas */\n  actions: Action[];\n  \n  /** Código gerado para Cypress */\n  code: {\n    cypress: string;\n    cypressTemplate?: string; // Nova versão com template\n  };\n}\n\n/**\n * Configuração do histórico\n */\nexport interface HistoryConfig {\n  /** Número máximo de gravações a manter */\n  maxEntries: number;\n  \n  /** Estratégia quando o limite é atingido */\n  pruneStrategy: 'drop-oldest' | 'error';\n}\n\n/**\n * Interface para backend de histórico\n */\nexport interface IHistoryBackend {\n  save(entry: RecordingEntry): Promise<void>;\n  list(): Promise<RecordingEntry[]>;\n  get(id: string): Promise<RecordingEntry | null>;\n  remove(id: string): Promise<void>;\n  clear(): Promise<void>;\n}",
    "processedAt": "2025-07-21T04:25:15.643Z"
  },
  {
    "path": "src/pages/Content/recorder.ts",
    "sha": "828147557b54b57e5aaeb9e68520ce7b5da5ecf7",
    "size": 11542,
    "summary": "O código implementa um sistema de gravação de ações do usuário na interface web, capturando eventos como cliques, inputs, teclas pressionadas, redimensionamentos e interações de drag-and-drop. Utiliza técnicas de debounce para otimizar eventos de resize e filtra eventos irrelevantes ou duplicados, garantindo a integridade e a precisão dos dados coletados. Além disso, integra-se com o armazenamento local do navegador para persistência e sincronização dos dados, suportando comunicação com background scripts para ações contextuais, o que permite um monitoramento detalhado e confiável do comportamento do usuário para fins de análise ou automação.",
    "content": "import debounce from 'lodash.debounce';\n\nimport genSelectors from '../builders/selector';\nimport { localStorageGet } from '../Common/utils';\n\nimport { ActionType, BaseAction, ResizeAction, TagName } from '../types';\n\nfunction isEventFromOverlay(event: Event) {\n  return (\n    event\n      .composedPath()\n      .find((element) => (element as HTMLElement).id === 'overlay-controls') !=\n    null\n  );\n}\n\n/**\n * This is directly derived from:\n * https://github.com/microsoft/playwright/blob/4ff69529d410144b30bcdbde9497ad600141a6b8/packages/playwright-core/src/server/supplements/injected/recorder.ts#L449\n */\nfunction _shouldGenerateKeyPressFor(event: KeyboardEvent): boolean {\n  // Backspace, Delete, AltGraph are changing input, will handle it there.\n  if (['AltGraph', 'Backspace', 'Delete'].includes(event.key)) return false;\n  // Ignore the QWERTZ shortcut for creating a at sign on MacOS\n  if (event.key === '@' && event.code === 'KeyL') return false;\n  // Allow and ignore common used shortcut for pasting.\n  if (navigator.platform.includes('Mac')) {\n    if (event.key === 'v' && event.metaKey) return false;\n  } else {\n    if (event.key === 'v' && event.ctrlKey) return false;\n    if (event.key === 'Insert' && event.shiftKey) return false;\n  }\n  if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key)) return false;\n  const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n  if (event.key.length === 1 && !hasModifier) return false;\n  return true;\n}\n\nfunction buildBaseAction(\n  event: Event,\n  overrideTarget?: HTMLElement\n): BaseAction {\n  const target = overrideTarget ?? (event.target as HTMLElement);\n\n  return {\n    isPassword:\n      target instanceof HTMLInputElement &&\n      target.type.toLowerCase() === 'password',\n    type: event.type as ActionType,\n    tagName: target.tagName as TagName,\n    inputType: target instanceof HTMLInputElement ? target.type : undefined,\n    selectors: genSelectors(target) ?? {},\n    timestamp: Date.now(),\n    hasOnlyText: target.children.length === 0 && target.innerText.length > 0,\n    value: undefined,\n  };\n}\n\nclass Recorder {\n  private _recording: any[];\n  private currentEventHandleType: string | null = null;\n  private onAction: any;\n  private lastContextMenuEvent: MouseEvent | null = null;\n  private firstUrlCaptured: boolean = false;\n\n  private appendToRecording = (action: any) => {\n    // Captura a primeira URL quando um evento relevante ocorre\n    if (!this.firstUrlCaptured && action.type !== ActionType.Resize) {\n      this.firstUrlCaptured = true;\n      // Só define firstUrl se ainda não estiver definida\n      chrome.storage.local.get(['firstUrl'], (result) => {\n        if (!result.firstUrl) {\n          const firstUrl = window.location.href;\n          chrome.storage.local.set({ firstUrl });\n        }\n      });\n    }\n\n    this._recording.push(action);\n    chrome.storage.local.set({ recording: this._recording });\n\n    if (this.onAction != null) {\n      this.onAction(action, this._recording);\n    }\n  };\n\n  private updateLastRecordedAction = (actionUpdate: any) => {\n    const lastAction = this._recording[this._recording.length - 1];\n    const newAction = {\n      ...lastAction,\n      ...actionUpdate,\n    };\n\n    this._recording[this._recording.length - 1] = newAction;\n    chrome.storage.local.set({ recording: this._recording });\n\n    if (this.onAction != null) {\n      this.onAction(newAction, this._recording);\n    }\n  };\n\n  /**\n   *\n   * @param event\n   * @returns true if it's already being handled somewhere else\n   */\n  private checkAndSetDuplicateEventHandle = (event: Event) => {\n    if (this.currentEventHandleType != null) {\n      return true; // This is a duplicate handle\n    }\n    this.currentEventHandleType = event.type;\n\n    setTimeout(() => {\n      this.currentEventHandleType = null;\n    }, 0);\n    return false; // This was not a duplicate handle\n  };\n\n  constructor({\n    onInitialized,\n    onAction,\n  }: {\n    onInitialized?: any;\n    onAction?: any;\n  }) {\n    this.onAction = onAction;\n    this._recording = [];\n    localStorageGet(['recording']).then(({ recording }) => {\n      this._recording = recording;\n\n      // Watch for changes to the recording from the background worker (when a SPA navigation happens)\n      chrome.storage.onChanged.addListener((changes) => {\n        if (\n          changes.recording != null &&\n          changes.recording.newValue != changes.recording.oldValue\n        ) {\n          this._recording = changes.recording.newValue;\n        }\n      });\n\n      window.addEventListener('click', this.onClick, true);\n      window.addEventListener('contextmenu', this.onContextMenu, true);\n      window.addEventListener('dragstart', this.onDrag, true);\n      window.addEventListener('drop', this.onDrag, true);\n      window.addEventListener('input', this.onInput, true);\n      window.addEventListener('keydown', this.onKeyDown, true);\n      window.addEventListener('resize', this.debouncedOnResize, true);\n      window.addEventListener('wheel', this.onMouseWheel, true);\n\n      // We listen to a context menu action\n      chrome.runtime.onMessage.addListener(this.onBackgroundMessage);\n\n      // Try capturing on start\n      // Note: some browsers will fire 'resize' event on load\n      this.onResize();\n\n      if (onInitialized != null) {\n        onInitialized(\n          this._recording?.[this._recording.length - 1],\n          this._recording\n        );\n      }\n    });\n  }\n\n  deregister() {\n    window.removeEventListener('click', this.onClick, true);\n    window.removeEventListener('contextmenu', this.onContextMenu, true);\n    window.removeEventListener('dragstart', this.onDrag, true);\n    window.removeEventListener('drop', this.onDrag, true);\n    window.removeEventListener('input', this.onInput, true);\n    window.removeEventListener('keydown', this.onKeyDown, true);\n    window.removeEventListener('resize', this.debouncedOnResize, true);\n    window.removeEventListener('wheel', this.onMouseWheel, true);\n  }\n\n  private onMouseWheel = (event: WheelEvent) => {\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n\n    const lastAction = this._recording[this._recording.length - 1];\n\n    const { pageXOffset, pageYOffset } = window;\n\n    if (\n      lastAction.type === 'wheel' &&\n      // We should record a new event if we've changed scroll directions\n      Math.sign(lastAction.deltaX) === Math.sign(event.deltaX) &&\n      Math.sign(lastAction.deltaY) === Math.sign(event.deltaY)\n    ) {\n      this.updateLastRecordedAction({\n        deltaX: Math.floor(lastAction.deltaX + event.deltaX),\n        deltaY: Math.floor(lastAction.deltaY + event.deltaY),\n        pageXOffset,\n        pageYOffset,\n      });\n    } else {\n      const action = {\n        type: 'wheel',\n        deltaX: Math.floor(event.deltaX),\n        deltaY: Math.floor(event.deltaY),\n        pageXOffset,\n        pageYOffset,\n        timestamp: Date.now(),\n      };\n      this.appendToRecording(action);\n    }\n  };\n\n  private onClick = (event: Event) => {\n    if (event.isTrusted === false) {\n      // Ignore synthetic events\n      return;\n    }\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n    if (this.checkAndSetDuplicateEventHandle(event)) {\n      return;\n    }\n\n    const target = event.target as HTMLElement;\n\n    // Choose the parent element if it's a link, since we probably want the link\n    const { parentElement } = target;\n    const predictedTarget =\n      parentElement?.tagName === 'A' ? parentElement : target;\n\n    const action = {\n      ...buildBaseAction(event, predictedTarget),\n    };\n\n    // @ts-ignore\n    this.appendToRecording(action);\n  };\n\n  private onDrag = (event: DragEvent) => {\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n\n    const lastAction = this._recording[this._recording.length - 1];\n\n    if (event.type === 'dragstart') {\n      this.appendToRecording({\n        ...buildBaseAction(event),\n        type: ActionType.DragAndDrop,\n        sourceX: event.x,\n        sourceY: event.y,\n      });\n    } else if (\n      event.type === 'drop' &&\n      lastAction.type === ActionType.DragAndDrop\n    ) {\n      this.updateLastRecordedAction({\n        targetX: event.x,\n        targetY: event.y,\n      });\n    }\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n    if (!_shouldGenerateKeyPressFor(event)) {\n      return;\n    }\n\n    // We're committed to handling, check and set handling flag\n    if (this.checkAndSetDuplicateEventHandle(event)) {\n      return;\n    }\n\n    const action = {\n      ...buildBaseAction(event),\n      key: event.key,\n    };\n\n    this.appendToRecording(action);\n  };\n\n  private onContextMenu = (event: MouseEvent) => {\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n\n    this.lastContextMenuEvent = event;\n  };\n\n  private onBackgroundMessage = (request: any) => {\n    // Context menu was clicked, pull last context menu element\n    if (\n      request != null &&\n      request.type === 'onHoverCtxMenu' &&\n      this.lastContextMenuEvent != null\n    ) {\n      const action = {\n        ...buildBaseAction(this.lastContextMenuEvent),\n        type: 'hover',\n        selectors: genSelectors(\n          this.lastContextMenuEvent.target as HTMLElement\n        ),\n      };\n      this.appendToRecording(action);\n    }\n    if (\n      request != null &&\n      request.type === 'onAwaitTextCtxMenu' &&\n      this.lastContextMenuEvent != null\n    ) {\n      const action = {\n        ...buildBaseAction(this.lastContextMenuEvent),\n        type: 'awaitText',\n        text: request.selectionText,\n        selectors: genSelectors(\n          this.lastContextMenuEvent.target as HTMLElement\n        ),\n      };\n      this.appendToRecording(action);\n    }\n  };\n\n  private onInput = (event: Event) => {\n    if (isEventFromOverlay(event)) {\n      return;\n    }\n\n    if (this.checkAndSetDuplicateEventHandle(event)) {\n      return;\n    }\n\n    const target = event.target as HTMLInputElement;\n    const selectors = genSelectors(target);\n    const lastAction = this._recording[this._recording.length - 1];\n    // If the last event was also an input and for the same element, update the last event with the latest input\n    if (\n      lastAction.type === 'input' &&\n      lastAction.selectors.generalSelector === selectors?.generalSelector\n    ) {\n      this.updateLastRecordedAction({\n        value: target?.value,\n        timestamp: Date.now(),\n      });\n    } else {\n      const action = {\n        ...buildBaseAction(event),\n        // @ts-ignore\n        value: target?.value,\n      };\n      this.appendToRecording(action);\n    }\n  };\n\n  private onResize = () => {\n    const lastResizeAction = this.getLastResizeAction();\n    const { innerWidth: width, innerHeight: height } = window;\n    if (\n      lastResizeAction == null ||\n      lastResizeAction.width !== width ||\n      lastResizeAction.height !== height\n    ) {\n      const action = {\n        type: ActionType.Resize,\n        width,\n        height,\n        timestamp: Date.now(),\n      };\n\n      this.appendToRecording(action);\n    }\n  };\n\n  private getLastResizeAction = (): ResizeAction => {\n    return this._recording.reduceRight((p, v) => {\n      if (p != null) {\n        return p;\n      }\n      if (v.type === 'resize') {\n        return v;\n      }\n    }, null);\n  };\n\n  private debouncedOnResize = debounce(this.onResize, 300);\n\n  public onFullScreenshot = (): void => {\n    const action = {\n      type: ActionType.FullScreenshot,\n      timestamp: Date.now(),\n    };\n\n    this.appendToRecording(action);\n  };\n}\n\nexport default Recorder;\n",
    "processedAt": "2025-07-21T04:25:16.872Z"
  },
  {
    "path": "src/pages/Common/endRecording.ts",
    "sha": "45ba5b2d5300c9c2de5d04d7769ab6c078788bee",
    "size": 1826,
    "summary": "O código implementa a finalização de uma sessão de gravação de ações do usuário em um ambiente de browser automation, garantindo a persistência dos dados capturados e a comunicação com a interface web. Ele recupera do armazenamento local as informações da gravação, identifica a URL inicial relevante para contextualizar a sessão, e salva a gravação no histórico por meio do serviço dedicado. Após a persistência, limpa o estado local para preparar futuras gravações e, se configurado, gera código Cypress correspondente às ações gravadas, enviando-o para a aba de origem. O comportamento é robusto, com tratamento de exceções e múltiplos pontos de decisão para assegurar a integridade dos dados e a continuidade do fluxo de trabalho automatizado.",
    "content": "import { setEndRecordingStorage, localStorageGet } from './utils';\nimport { genCypressCode } from '../builders';\nimport { RecordingService } from '../storage/recording-service';\nimport { Action } from '../types';\n\nexport async function endRecording() {\n  const { recording, returnTabId, recordingStartTime, firstUrl } = await localStorageGet([\n    'recording',\n    'returnTabId',\n    'recordingStartTime',\n    'firstUrl',\n  ]);\n\n  // Salva a gravação no histórico se houver ações gravadas\n  if (recording && recording.length > 0) {\n    try {\n      // Usa a primeira URL capturada ou busca a primeira ação Navigate\n      let url = firstUrl;\n      \n      if (!url) {\n        // Fallback: procura primeira ação Navigate\n        const firstNavigate = (recording as Action[]).find(action => action.type === 'navigate');\n        if (firstNavigate && 'url' in firstNavigate) {\n          url = firstNavigate.url;\n        } else {\n          // Se ainda não tiver, usa a URL atual da aba\n          const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n          url = activeTab?.url || 'unknown';\n        }\n      }\n      \n      // Cria a entrada no histórico\n      await RecordingService.createRecording(\n        recording as Action[],\n        url,\n        recordingStartTime || recording[0]?.timestamp,\n        Date.now()\n      );\n    } catch (error) {\n      console.error('Erro ao salvar gravação no histórico:', error);\n    }\n  }\n\n  // Limpa o storage da gravação atual\n  setEndRecordingStorage();\n\n  // We need to send the generated recording back to the webapp\n  if (returnTabId != null) {\n    const code = genCypressCode(recording, true);\n\n    chrome.runtime.sendMessage({\n      type: 'forward-recording',\n      tabId: returnTabId,\n      code,\n      actions: recording,\n    });\n  }\n}\n",
    "processedAt": "2025-07-21T04:25:16.990Z"
  },
  {
    "path": "src/pages/Popup/components/RecordingDetail.tsx",
    "sha": "c6c2a07c02fac7f30566000d0011541817d2e9eb",
    "size": 11531,
    "summary": "O componente RecordingDetail é uma interface React que exibe detalhes de uma gravação de teste automatizado, permitindo ao usuário visualizar ações capturadas ou o código Cypress gerado para reprodução. Ele gerencia estados internos para alternar entre visualização de ações e código, controla a cópia do código para a área de transferência, possibilita o download do script gerado e oferece funcionalidades para iniciar, monitorar e interromper a reprodução do teste, com feedback visual do status do replay. A integração com hooks personalizados e utilitários auxilia na geração dinâmica do código, manipulação do download e controle do fluxo de replay, garantindo uma experiência interativa e responsiva para análise e execução de gravações de testes automatizados.",
    "content": "/**\n * Componente para exibir os detalhes de uma gravação específica\n */\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { RecordingEntry } from '../../types/recording';\nimport { ScriptType } from '../../types';\nimport { useReplay } from '../../../hooks/use-replay';\nimport { ReplayMode } from '../../../types/replay';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { genCypressCodeWithTemplate } from '../../builders';\nimport {\n  faChevronLeft,\n  faCode,\n  faList,\n  faCopy,\n  faCheck,\n  faPlay,\n  faCalendarAlt,\n  faTasks,\n  faGlobe,\n  faDownload,\n  faRedo,\n  faStop,\n  faSpinner,\n} from '@fortawesome/free-solid-svg-icons';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport ActionList from '../../Content/ActionList';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { truncateText } from '../../Common/utils/text';\nimport {\n  downloadTestFile,\n  prepareTestDownload,\n} from '../../Common/utils/download';\nimport '../themes/dark-core.css';\nimport './recording-detail.css';\n\ninterface RecordingDetailProps {\n  recording: RecordingEntry;\n  onBack: () => void;\n}\n\n/**\n * Componente de detalhes da gravação\n */\nexport const RecordingDetail: React.FC<RecordingDetailProps> = ({\n  recording,\n  onBack,\n}) => {\n  const [viewMode, setViewMode] = useState<'actions' | 'code'>('code');\n  const [copied, setCopied] = useState(false);\n  const [replayMode, setReplayMode] = useState<ReplayMode>(ReplayMode.KEEP_CACHE);\n  const { replayState, isReplaying, startReplay, stopReplay, error } = useReplay();\n\n  const getCypressCode = useMemo((): string => {\n    console.log('🔄 [RecordingDetail] Gerando código para Cypress');\n    \n    // Se já tem o template novo, usa ele\n    if (recording.code.cypressTemplate) {\n      return recording.code.cypressTemplate;\n    }\n    \n    // Senão, gera o template novo a partir das ações\n    try {\n      return genCypressCodeWithTemplate(recording.actions, {\n        testName: recording.title,\n        url: recording.url,\n        exportOptions: {\n          viewportWidth: 1366,\n          viewportHeight: 768\n        }\n      }, true);\n    } catch (error) {\n      console.error('❌ Erro ao gerar template novo, usando código antigo:', error);\n      return recording.code.cypress;\n    }\n  }, [recording]);\n\n  const handleCopy = useCallback(() => {\n    console.log(\n      '📋 [RecordingDetail] Código copiado para área de transferência'\n    );\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n  }, []);\n\n  const handleDownload = useCallback(() => {\n    try {\n      const code = getCypressCode;\n      const { filename, content } = prepareTestDownload(code, recording.title);\n      downloadTestFile(filename, content);\n    } catch (error) {\n      console.error('❌ [RecordingDetail] Erro ao baixar teste:', error);\n    }\n  }, [getCypressCode, recording.title]);\n\n  const handleReplay = useCallback(async () => {\n    try {\n      console.log('🎬 [RecordingDetail] Iniciando replay da gravação:', recording.id, 'Modo:', replayMode);\n      await startReplay(recording.id, replayMode);\n    } catch (error) {\n      console.error('❌ [RecordingDetail] Erro ao iniciar replay:', error);\n    }\n  }, [recording.id, replayMode, startReplay]);\n\n  const handleStopReplay = useCallback(() => {\n    console.log('⏹️ [RecordingDetail] Parando replay');\n    stopReplay();\n  }, [stopReplay]);\n\n  const formatDate = (timestamp: number): string => {\n    const date = new Date(timestamp);\n    return date.toLocaleDateString('pt-BR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  const formatDuration = (start: number, end: number): string => {\n    const duration = end - start;\n    const seconds = Math.floor(duration / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n\n    if (minutes > 0) {\n      return `${minutes}m ${remainingSeconds}s`;\n    }\n    return `${seconds}s`;\n  };\n\n  return (\n    <div className=\"ds-dark recording-detail\">\n      {/* Header */}\n      <div className=\"recording-detail-header\">\n        <div className=\"recording-detail-header-info\">\n          <h2 className=\"recording-detail-title\">\n            <FontAwesomeIcon icon={faPlay} />\n            <span className=\"recording-detail-title-text\">\n              {truncateText(recording.title, 50)}\n            </span>\n          </h2>\n          <div className=\"recording-detail-meta\">\n            <span className=\"recording-detail-meta-item\">\n              <FontAwesomeIcon\n                icon={faCalendarAlt}\n                className=\"recording-detail-meta-icon\"\n              />\n              {formatDate(recording.startedAt)}\n            </span>\n            <span className=\"recording-detail-meta-item\">\n              <FontAwesomeIcon\n                icon={faTasks}\n                className=\"recording-detail-meta-icon\"\n              />\n              {recording.actions.length} ações em{' '}\n              {formatDuration(recording.startedAt, recording.endedAt)}\n            </span>\n            <span className=\"recording-detail-meta-item\">\n              <FontAwesomeIcon\n                icon={faGlobe}\n                className=\"recording-detail-meta-icon\"\n              />\n              <span className=\"recording-detail-meta-url\" title={recording.url}>\n                {recording.hostname}\n              </span>\n            </span>\n          </div>\n        </div>\n        <button className=\"recording-btn recording-btn-back\" onClick={onBack}>\n          <FontAwesomeIcon icon={faChevronLeft} />\n          Voltar\n        </button>\n      </div>\n\n      {/* Content */}\n      <div className=\"recording-detail-content\">\n        {/* Toolbar */}\n        <div className=\"recording-detail-toolbar\">\n          <div className=\"recording-detail-tabs\">\n            <button\n              className={`recording-detail-tab ${\n                viewMode === 'actions' ? 'active' : ''\n              }`}\n              onClick={() => setViewMode('actions')}\n            >\n              <FontAwesomeIcon icon={faList} />\n              Ações\n            </button>\n            <button\n              className={`recording-detail-tab ${\n                viewMode === 'code' ? 'active' : ''\n              }`}\n              onClick={() => setViewMode('code')}\n            >\n              <FontAwesomeIcon icon={faCode} />\n              Código\n            </button>\n          </div>\n\n          {viewMode === 'code' && (\n            <div className=\"recording-detail-actions\">\n              <span className=\"recording-detail-script-type\">Cypress</span>\n\n              <CopyToClipboard text={getCypressCode} onCopy={handleCopy}>\n                <button className=\"recording-btn recording-btn-secondary\">\n                  <FontAwesomeIcon icon={copied ? faCheck : faCopy} />\n                  {copied ? 'Copiado!' : 'Copiar'}\n                </button>\n              </CopyToClipboard>\n\n              <button\n                className=\"recording-btn recording-btn-primary\"\n                onClick={handleDownload}\n              >\n                <FontAwesomeIcon icon={faDownload} />\n                Baixar teste\n              </button>\n            </div>\n          )}\n\n          {viewMode === 'actions' && (\n            <div className=\"recording-detail-actions\">\n              {isReplaying ? (\n                <button \n                  className=\"recording-btn recording-btn-danger\"\n                  onClick={handleStopReplay}\n                >\n                  <FontAwesomeIcon icon={faStop} />\n                  Parar Replay\n                </button>\n              ) : (\n                <>\n                  <select \n                    className=\"recording-select\"\n                    value={replayMode}\n                    onChange={(e) => setReplayMode(e.target.value as ReplayMode)}\n                  >\n                    <option value={ReplayMode.KEEP_CACHE}>Manter Cache</option>\n                    <option value={ReplayMode.CLEAN_CACHE}>Limpar Cache</option>\n                  </select>\n                  <button \n                    className=\"recording-btn recording-btn-primary\"\n                    onClick={handleReplay}\n                    disabled={recording.actions.length === 0}\n                  >\n                    <FontAwesomeIcon icon={faRedo} />\n                    Reproduzir\n                  </button>\n                </>\n              )}\n            </div>\n          )}\n        </div>\n\n        {/* Replay Status */}\n        {replayState && replayState.status !== 'idle' && (\n          <div className={`recording-detail-replay-status ${\n            replayState.status === 'error' ? 'error' : ''\n          }`}>\n            <div className=\"recording-detail-replay-status-content\">\n              {replayState.status === 'preparing' && (\n                <>\n                  <FontAwesomeIcon icon={faSpinner} spin />\n                  <span>Preparando replay...</span>\n                </>\n              )}\n              {replayState.status === 'running' && (\n                <>\n                  <FontAwesomeIcon icon={faPlay} />\n                  <span>\n                    Executando: {replayState.currentStepIndex + 1} de {replayState.totalSteps} ações\n                  </span>\n                  <div className=\"recording-detail-replay-progress\">\n                    <div \n                      className=\"recording-detail-replay-progress-bar\"\n                      style={{ \n                        width: `${(replayState.currentStepIndex / replayState.totalSteps) * 100}%` \n                      }}\n                    />\n                  </div>\n                </>\n              )}\n              {replayState.status === 'completed' && (\n                <>\n                  <FontAwesomeIcon icon={faCheck} />\n                  <span>Replay concluído com sucesso!</span>\n                </>\n              )}\n              {replayState.status === 'error' && (\n                <>\n                  <FontAwesomeIcon icon={faSpinner} />\n                  <span>Erro: {replayState.error || error || 'Erro desconhecido'}</span>\n                </>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* View Content */}\n        <div className=\"recording-detail-view\">\n          {viewMode === 'actions' ? (\n            <div className=\"recording-detail-actions-view\">\n              <ActionList actions={recording.actions} />\n            </div>\n          ) : (\n            <div className=\"recording-detail-code-view\">\n              <div className=\"recording-detail-code-header\">\n                <span className=\"recording-detail-code-title\">\n                  Código Cypress Gerado\n                </span>\n              </div>\n              <div className=\"recording-detail-code-content\">\n                <SyntaxHighlighter\n                  language=\"javascript\"\n                  style={vscDarkPlus}\n                  customStyle={{\n                    background: 'none',\n                    padding: 0,\n                    overflow: 'auto',\n                    paddingRight: '1em',\n                    paddingBottom: '1em',\n                  }}\n                  data-testid=\"code-block\"\n                >\n                  {getCypressCode}\n                </SyntaxHighlighter>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n",
    "processedAt": "2025-07-21T04:25:18.079Z"
  },
  {
    "path": "webpack.config.js",
    "sha": "e52eedca72cfc5f8210a6d0a6cf64eb30a26f818",
    "size": 4294,
    "summary": "Não foi possível gerar descrição",
    "content": "var webpack = require('webpack'),\n  path = require('path'),\n  fileSystem = require('fs-extra'),\n  env = require('./utils/env'),\n  { CleanWebpackPlugin } = require('clean-webpack-plugin'),\n  CopyWebpackPlugin = require('copy-webpack-plugin'),\n  HtmlWebpackPlugin = require('html-webpack-plugin'),\n  TerserPlugin = require('terser-webpack-plugin');\n\nconst ASSET_PATH = process.env.ASSET_PATH || '/';\nconst MANIFEST_VERSION = process.env.MANIFEST_VERSION;\n\nvar alias = {\n  'react-dom': '@hot-loader/react-dom',\n};\n\n// load the secrets\nvar secretsPath = path.join(__dirname, 'secrets.' + env.NODE_ENV + '.js');\n\nvar fileExtensions = [\n  'jpg',\n  'jpeg',\n  'png',\n  'gif',\n  'eot',\n  'otf',\n  'svg',\n  'ttf',\n  'woff',\n  'woff2',\n];\n\nif (fileSystem.existsSync(secretsPath)) {\n  alias['secrets'] = secretsPath;\n}\n\nvar options = {\n  mode: process.env.NODE_ENV || 'development',\n  entry: {\n    popup: path.join(__dirname, 'src', 'pages', 'Popup', 'index.jsx'),\n    background: path.join(__dirname, 'src', 'pages', 'Background', 'index.ts'),\n    contentScript: path.join(__dirname, 'src', 'pages', 'Content', 'index.tsx'),\n    bridge: path.join(__dirname, 'src', 'pages', 'Bridge', 'index.ts'),\n    cypressTrigger: path.join(\n      __dirname,\n      'src',\n      'pages',\n      'CypressTrigger',\n      'index.tsx'\n    ),\n    replayRunner: path.join(__dirname, 'src', 'modules', 'replay', 'replay-runner.ts'),\n  },\n  chromeExtensionBoilerplate: {\n    notHotReload: ['contentScript' /*, 'devtools'*/],\n  },\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    filename: '[name].bundle.js',\n    publicPath: ASSET_PATH,\n  },\n  module: {\n    rules: [\n      {\n        // Content script styles need to be embedded inline due to shadow dom usage\n        test: /\\.(css|scss)$/,\n        type: 'asset/source',\n      },\n      {\n        test: new RegExp('.(' + fileExtensions.join('|') + ')$'),\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]',\n        },\n        exclude: /node_modules/,\n      },\n      {\n        test: /\\.html$/,\n        loader: 'html-loader',\n        exclude: /node_modules/,\n      },\n      { test: /\\.(ts|tsx)$/, loader: 'ts-loader', exclude: /node_modules/ },\n      {\n        test: /\\.(js|jsx)$/,\n        use: [\n          {\n            loader: 'source-map-loader',\n          },\n          {\n            loader: 'babel-loader',\n          },\n        ],\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    alias: alias,\n    extensions: fileExtensions\n      .map((extension) => '.' + extension)\n      .concat(['.js', '.jsx', '.ts', '.tsx', '.css']),\n  },\n  plugins: [\n    new webpack.ProgressPlugin(),\n    // clean the build folder\n    new CleanWebpackPlugin({\n      verbose: true,\n      cleanStaleWebpackAssets: true,\n    }),\n    // expose and write the allowed env vars on the compiled bundle\n    new webpack.EnvironmentPlugin(['NODE_ENV']),\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: `src/manifest${MANIFEST_VERSION}.json`,\n          to: path.join(__dirname, 'build', 'manifest.json'),\n          force: true,\n          transform: function (content, path) {\n            // generates the manifest file using the package.json informations\n            return Buffer.from(\n              JSON.stringify({\n                // description: process.env.npm_package_description,\n                version: process.env.npm_package_version,\n                ...JSON.parse(content.toString()),\n              })\n            );\n          },\n        },\n      ],\n    }),\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: 'src/assets/img',\n          to: path.join(__dirname, 'build'),\n          force: true,\n        },\n      ],\n    }),\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, 'src', 'pages', 'Popup', 'index.html'),\n      filename: 'popup.html',\n      chunks: ['popup'],\n      cache: false,\n    }),\n  ],\n  infrastructureLogging: {\n    level: 'info',\n  },\n};\n\nif (env.NODE_ENV === 'development') {\n  options.devtool = 'cheap-module-source-map';\n} else {\n  options.optimization = {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        extractComments: false,\n        terserOptions: {\n          mangle: false,\n        },\n      }),\n    ],\n  };\n}\n\nmodule.exports = options;\n",
    "processedAt": "2025-07-21T04:25:49.239Z"
  },
  {
    "path": "src/types/replay.ts",
    "sha": "6a09fb00722e86227832a17f33318c2e7d6c69c4",
    "size": 1836,
    "summary": "Este arquivo define tipos TypeScript para um sistema de replay de gravações de ações do usuário, incluindo enumerações, interfaces e tipos que modelam o estado, mensagens e resultados do replay. O código estrutura a comunicação entre componentes do sistema, permitindo iniciar, monitorar, executar e reportar o progresso e resultados do replay, com suporte a modos de cache e controle detalhado do estado. A modelagem tipada assegura integridade e clareza na manipulação dos dados, facilitando a integração e manutenção do sistema de replay em aplicações complexas.",
    "content": "/**\n * Tipos TypeScript para o sistema de replay de gravações\n */\n\nimport type { Action } from '../pages/types/index';\n\n/**\n * Modos de replay disponíveis\n */\nexport enum ReplayMode {\n  /** Mantém o cache atual do navegador */\n  KEEP_CACHE = 'keep-cache',\n  /** Limpa todo o cache antes de iniciar */\n  CLEAN_CACHE = 'clean-cache'\n}\n\n/**\n * Status possíveis durante o replay\n */\nexport type ReplayStatus = 'idle' | 'preparing' | 'running' | 'paused' | 'completed' | 'error';\n\n/**\n * Estado do replay\n */\nexport interface ReplayState {\n  status: ReplayStatus;\n  currentStepIndex: number;\n  totalSteps: number;\n  startTime: number | null;\n  error?: string;\n}\n\n/**\n * Mensagem de requisição para iniciar replay\n */\nexport interface ReplayRequest {\n  type: 'REPLAY_REQUEST';\n  recordingId: string;\n  tabId?: number;\n  mode?: ReplayMode;\n}\n\n/**\n * Mensagem de atualização de status do replay\n */\nexport interface ReplayStatusUpdate {\n  type: 'REPLAY_STATUS';\n  state: ReplayState;\n  tabId: number;\n}\n\n/**\n * Mensagem para executar ações no runner\n */\nexport interface ReplayExecute {\n  type: 'REPLAY_EXECUTE';\n  actions: Action[];\n  initialUrl: string;\n  mode?: ReplayMode;\n}\n\n/**\n * Mensagem de resultado da execução\n */\nexport interface ReplayResult {\n  type: 'REPLAY_RESULT';\n  success: boolean;\n  error?: string;\n  completedSteps: number;\n}\n\n/**\n * União de todos os tipos de mensagem de replay\n */\nexport type ReplayMessage = \n  | ReplayRequest \n  | ReplayStatusUpdate \n  | ReplayExecute \n  | ReplayResult;\n\n/**\n * Opções para o executor de ações\n */\nexport interface ActionExecutorOptions {\n  waitTimeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n}\n\n/**\n * Resultado da execução de uma ação\n */\nexport interface ActionExecutionResult {\n  success: boolean;\n  error?: string;\n  duration?: number;\n}",
    "processedAt": "2025-07-21T04:25:49.382Z"
  }
]