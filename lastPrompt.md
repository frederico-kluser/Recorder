<claude_code_execution>
  <mode>autonomous_implementation</mode>
  <priority>execute_immediately</priority>

  <task>
    Implementar o plano fornecido no projeto Ondokai usando Claude Code.
  </task>

  <execution_instructions>
    1. Analisar o implementation_plan
    2. Identificar arquivos a criar/modificar
    3. Executar implementação completa
  </execution_instructions>

  <implementation_plan>
    Comando original: Atualmente, estamos com um problema na nossa aplicação. Quando terminamos a gravação, a URL que é salva é a URL do momento em que pausamos a gravação. Isso está errado. Quero que remova esse comportamento. A URL que deve ser salva, tanto para uso no código Cypress quanto no modo replay, deve ser a URL do início da gravação, e nenhuma outra. Nenhuma outra URL além daquela deve ser utilizada, em todos os contextos, inclusive no Cypress e no replay. Outro ponto: revise todo o modo replay, revise completamente, porque o replay não está funcionando, principalmente por causa dessa questão da URL.

Último plano: O plano detalha onde alterar coleta, persistência e consumo da startUrl, ajustando storage, builders, replay-handler e replay-runner. Inclui estratégias de testes, performance e segurança para assegurar consistência absoluta da URL inicial em todos os contextos.

Pergunta 1: Q1 - Qual é o problema principal e como vamos resolvê-lo especificamente?
Resposta: A gravação salva currentTab.url no momento do pause via utils.endRecording, gerando inconsistência no histórico e falhas de replay. Removeremos a leitura tardia e armazenaremos somente startUrl obtida em utils.startRecording. Ajustaremos RecordEntry para campo urlOriginal, populado na criação da gravação. Arquivos afetados: src/pages/Common/utils.ts (startRecording, endRecording), src/pages/storage/recording-store.ts (migrar campo). Flow: startRecording captura → gravação persiste → builders e replay usam a mesma string.

Pergunta 2: Q2 - Como os dados serão estruturados e qual a estratégia de persistência?
Resposta: Interface RecordingEntry terá { id:string, startedAt:number, urlOriginal:string, actions:Action[], code:string }. src/pages/types/recording.ts será atualizado e migrado via função migrateUrlField() em recording-store.ts, convertendo url → urlOriginal se ausente. Persistência continua em chrome.storage.local; serialização via JSON.stringify com replacer que converte Date para epoch. Exemplo de chave: ds:v2:recordings.

Pergunta 3: Q3 - Quais módulos existentes serão integrados e como?
Resposta: 1) endRecording.ts deixará de chamar getActiveTabUrl; passará startUrl recebido via parâmetro. 2) genCypressCodeWithTemplate usará entry.urlOriginal para set baseUrl no template. 3) replay-handler.ts enviará urlOriginal no ReplayInitMessage; replay-runner.ts navegará diretamente para esse URL na primeira action Navigate fake. Imports ajustados em src/modules/replay/*.ts adicionando type RecordingEntry atualizado.

Pergunta 4: Q4 - Quais casos extremos e erros devemos tratar?
Resposta: Extremos: a) startRecording falha em obter tab.url → lançar StartRecordingError e abortar; b) migração detecta entradas sem URL válida → move para quarantine store; c) replay-runner recebe URL com protocolo inválido → aborta e envia ReplayError "INVALID_URL"; d) storage quota exceeded → rotate oldest entry antes de salvar. Exceptions customizadas exportadas de errors.ts.

Pergunta 5: Q5 - Como tornar a solução configurável e extensível?
Resposta: Adicionaremos RecordingConfig em src/pages/types: { maxEntries:number, pruneStrategy:"FIFO"|"TTL", defaultProtocol:"https" }. Arquivo config/default.json conterá { "maxEntries":500, "pruneStrategy":"FIFO" }. utils.startRecording normaliza URL aplicando defaultProtocol se ausente. Hooks usePreferences exposto para futuros ajustes via UI.

Pergunta 6: Q6 - Qual a arquitetura técnica detalhada da implementação?
Resposta: Padrões: Singleton (RecordingStore), Factory (ActionBuilderFactory), Observer (chrome.runtime.onMessage). Diagrama: UI Popup ⇆ RecordingStore ⇆ chrome.storage.local; Recorder(content) → messages → Background → RecordingStore; ReplayHandler(popup) → Runner(tab). Cada componente conhece apenas sua interface, garantindo baixo acoplamento e testabilidade.

Pergunta 7: Q7 - Como garantir performance e escalabilidade?
Resposta: Complexidade de save O(1) com Map cache; migração roda uma vez em O(n). Replay-runner pré-carrega actions em memória e usa batching para domQuery (max 20QPS). Debounce de save 200 ms evita writes excessivas. Benchmarks esperados: gravação 1k actions <50 ms persistência; replay 1k actions em 8 s média. Monitoramento: PerformanceObserver + console.time.

Pergunta 8: Q8 - Quais validações e medidas de segurança implementar?
Resposta: Validações: regex URL ^https?:\/\/; sanitização via DOMPurify quando exibida. Política CSP já impede inline scripts; replay-runner bloqueia navigation se host divergir de urlOriginal.host. Secrets mantidos no manifest "storage" somente. Permissões extras (tabs) revisadas para mínimo necessário.

Pergunta 9: Q9 - Como testar completamente a implementação?
Resposta: Unit: endRecording.test.ts verifica que urlOriginal === startUrl. Migration.test.ts cria fixture v1 sem urlOriginal e checa upgrade. Integration: replay-handler.test.ts simula mensagem INIT e garante tab.url === urlOriginal. E2E Cypress: grava domínio exemplo.com, pausa em /login, confirma histórico guarda / (root). Cobertura alvo 90% linhas nos módulos alterados.

Pergunta 10: Q10 - Como validar que a implementação está correta e completa?
Resposta: Checklist: 1) startUrl salvo no JSON export. 2) Código Cypress contém cy.visit(urlOriginal). 3) Replay abre aba na urlOriginal e executa ações. 4) Testes passam CI. 5) migration log sem warnings. Métricas: 0 regressions em suite, 100% gravações com urlOriginal presente, erro de replay <1%. Documentação atualizada em CHANGELOG.md e README.
  </implementation_plan>

  <context_reference>
    <onboarding_summary>
      <context>
<system_architecture>
  <project_metadata>
    <name>React Application Setup, build, processo de construção do projeto, Fleury Cypress Recorder, Extensão para geração automática de scripts de teste, Projeto TypeScript com Jest para testes automatizados, deploysentinel-recorder, Extensão para geração automática de scripts Cypress, Extensão para gravação de interações e geração de scripts de teste, DeploySentinel, Extensão para gravação e replay de testes automatizados, DeploySentinel Test Recorder, Automação de testes Playwright, React Icon Component, Componente de ícone SVG para interface web, Interface para monitoramento e deploy de aplicações, Projeto de automação de testes com Cypress, Browser Automation Recording Service, Captura e persistência de sessões de gravação de ações do usuário para testes automatizados, Automação de Testes UI com Cypress, DeploySentinel - Extensão para gravação e automação de testes em navegadores, Automated UI Testing Script Visualizer, Code Generation UI, Visualização e geração dinâmica de código, Recorder ControlBar - Interface para gravação e geração de scripts de automação de testes, Highlighter Component, Visualização e destaque de seletores CSS em UI React, Interface de controle para monitoramento e testes, User Interaction Recorder, Captura e gravação detalhada de eventos de usuário para análise comportamental e automação, DeploySentinel Cypress Test Recorder, Ferramenta para gravação de testes automatizados com Cypress, Cypress Test Recorder Extension, Analytics Event Tracker, Monitoramento de eventos para análise de uso, Popup UI Renderer, Interface para exibição de popups com temas dinâmicos, @medv/finder, CSS Selector Generator, Gerador de scripts de teste automatizado, UI Test Selector Generator, Automação de Seletores para Testes de Interface, Projeto Front-end com suporte a importação de assets estáticos, Browser Extension Compatibility Layer, Projeto React com TypeScript para front-end moderno, Webpack Production Build Script, Configuração de ambiente para aplicação Node.js, Chrome Extension Boilerplate, Development Environment Setup, Projeto Node.js com controle de versionamento otimizado, Timestamp Migration and Validation Utility, Cypress Script Automation, Automação de scripts de teste end-to-end com Cypress, Extensão para gravação de testes Cypress, UI Component Library, Button and Layout Styling, Replay Test Automation, Interface para visualização e reprodução de gravações de testes automatizados, Recording History Manager, Interface para gerenciamento e visualização de gravações de sessões, Web UI Base Styling, Recording Management Service, Serviço para gerenciamento de gravações de ações para automação de testes, Gerenciamento de histórico de gravações para extensões Chrome, Recording History System - Gerenciamento e Persistência de Sessões de Gravação, Dark Theme UI Styling, Unified dark mode theme for web application, Fleury Brand Identity Component, Layout Dark Mode Unificado, Interface Web Responsiva, Popup UI Consistency Wrapper, Popup Recording History UI, Interface para visualização e interação com histórico de gravações, RecordingDetail Dark Theme, Interface para visualização detalhada de gravações, RecordingHistory UI Theme, Interface para histórico de gravações, Recording History UI, Interface para gerenciamento e visualização de gravações, Cypress Test Exporter, Ferramenta para exportação automatizada de testes Cypress, Text Utilities Module, Manipulação e truncamento de textos para UI, RecordingDetail Component - Visualização detalhada de gravações, RecordingHistory Component, Interface para gerenciamento de histórico de gravações, Extensão com popup estilizado para interface dark mode, Tema Dark Unificado Fleury, Sistema de Gerenciamento de Dados Empresariais, Replay Manager - Controle de reprodução de gravações em extensão Chrome, Replay Module, Centralização de funcionalidades de replay de gravações, Replay Automation System, Gerenciamento e execução de replays de gravações de ações em navegador, ReplayRunner - Execução automatizada de ações gravadas para testes e automação, Replay System, Sistema para reprodução automatizada de gravações de ações, Exportação automatizada de testes Cypress</name>
    <domain>Web Development, Frontend, React, desenvolvimento de software, automação de build, Automação de testes, QA, Test Automation, Browser Testing, Desenvolvimento de software, Testes automatizados, TypeScript, Browser Extensions, Browser Interaction Recording, End-to-End Testing, Web Testing, Browser Extension, Playwright, Frontend Development, UI Components, DevOps, Branding, Quality Assurance, Test Scripts, Browser Automation, Test Recording, Cypress Integration, UI Testing, Cypress, Automação de testes, extensões de navegador, gravação de sessões, Cypress integration, UI Interaction, Web Application Testing, Automação de geração de código, Developer Tools, UI Debugging, CSS Selector Highlighting, Web UI Testing, Shadow DOM, Web Analytics, User Behavior Tracking, Terminologia técnica: DOM events, selectors, debounce, SPA navigation, Automated Testing, Digital Product Monitoring, Google Analytics, Frontend Web Application, UI/UX Components, Theming and Styling, DOM Manipulation, CSS Selectors, Testes end-to-end, Web testing, Automação de Testes, Testes End-to-End, Seletores CSS, Desenvolvimento front-end, Assets estáticos, CSS Modules, SVG inline, browser extensions, cross-browser compatibility, Interação com UI web, Web applications, Desenvolvimento Frontend, Build Automation, JavaScript, Configuração de software, Node.js environment management, Chrome Extensions, Frontend Tooling, Node.js, Controle de versão, Software Development, Event Processing, Action Logging, Frontend Styling, UI/UX, Automação de testes de software, Test Automation, Cypress, Replay, UI Testing, Web Application, User Session Recording, Frontend React, Data Management, Recording Actions, User Action Recording, chrome.storage API, Automação de testes, gravação de ações de usuário, QA, Cypress, Web Testing, UI/UX Design, Healthcare, Web Application UI, Dark Theme Design, Frontend UI, Popup Interface, Software de gravação, UX/UI para análise de gravações, Dark theme styling, Software de monitoramento, Recording analysis, UI/UX design, User Interface, Recording Management, Media Management, User Interaction, Recording Analytics, Text Processing, Interface de usuário para análise de gravações em sistemas de monitoramento e replay, terminologia técnica em inglês para precisão (ex: replay, toolbar, tabs), Recording History, Extensões de navegador, Dark mode theming, Front-end Development, Theming, Dark Mode, Enterprise Data Management, Data Integrity, Business Rules, Extensões de navegador, automação de testes, UX/UI replay, Chrome API, Replay de gravações, Monitoramento, Análise de sessões, Replay Testing, Extensões Chrome, User Interaction Replay, Sistemas web</domain>
    <current_phase>Development, produção, deploy, Produção, Manutenção ativa, Manutenção, Versão 0.7.1 estável, Estável, Estabilização, Estabilização e manutenção, Produção com suporte a múltiplas versões de manifest (v2 e v3), Production, Estável com monitoramento ativo e suporte a múltiplos eventos, Estável com suporte a hot reload para desenvolvimento, MVP, Desenvolvimento ativo, Desenvolvimento inicial, Local Testing, Desenvolvimento, Testes unitários implementados, Testes automatizados integrados, Estável com funcionalidades completas para visualização e replay, Estável com funcionalidades completas de CRUD e import/export, Stable UI Theme, Estabilização de UI, Estabilização visual e usabilidade, Estabilização do tema visual, Estabilização visual, Estabilização UI, Stable Utility Functions, Estabilização visual e responsiva, Manutenção e melhoria contínua</current_phase>
    <critical_business_rules>Preserve fast refresh functionality, Ensure JSX transpilation compatibility, build deve gerar artefatos consistentes, não quebrar pipeline de deploy, Captura precisa e completa dos eventos do usuário, Geração correta e legível dos scripts, Compatibilidade com múltiplos frameworks de teste, Execução consistente dos testes, Suporte a TypeScript via ts-jest, Ambiente Node.js para testes, Compatibilidade com manifest v2 e v3, Geração precisa e confiável de scripts Cypress, Manutenção da integridade dos scripts gerados, Gravação precisa das interações do usuário, Geração correta de scripts compatíveis com Cypress, Playwright e Puppeteer, Segurança no acesso às permissões do navegador, Segurança e privacidade dos dados capturados, Gravação só ativa em aba e frame corretos, Estado de gravação deve ser consistente, Scripts injetados devem ser executados apenas em contexto autorizado, Validação rigorosa da origem das mensagens, Comunicação segura entre webapp e extensão, Consistência visual do ícone, Compatibilidade com React 18+, Renderização correta do SVG, Consistência visual da marca, Performance mínima no carregamento do logo, Tipo de script deve ser sempre Cypress, Interface deve manter compatibilidade visual, Persistir gravações somente se houver ações registradas, Garantir que a URL inicial da gravação seja sempre identificada para contexto, Enviar código gerado apenas para a aba correta, Limpar estado local após finalização para evitar dados inconsistentes, Uso obrigatório da biblioteca Cypress para scripts, Persistência consistente das preferências do usuário, Sincronização em tempo real do estado de gravação, Persistência correta do estado de gravação para evitar perda de dados, Compatibilidade entre manifest v2 e v3 para execução de scripts, Identificação precisa de abas de teste Cypress para integração adequada, Only supported action types should be rendered, Sensitive input values must be masked, Geração correta e precisa do código, Manter integridade do código gerado, Renderização fiel do código para análise, Integridade das ações gravadas, Sincronização do estado de gravação, Precisão na geração de seletores e código, Precisão no posicionamento do destaque, Renderização consistente do rótulo, Não interferir na interação do usuário, Garantir única instância ativa do script, Permitir limpeza completa do componente para evitar vazamentos, Não registrar eventos duplicados para o mesmo tipo em sequência imediata, Ignorar eventos originados da interface de overlay para evitar ruído, Persistir gravação no armazenamento local para recuperação e continuidade, Capturar a primeira URL visitada apenas uma vez para contexto da sessão, Garantir que apenas uma gravação esteja ativa por vez, Não montar múltiplos botões no DOM, Comunicação correta com a extensão Chrome, Preservar integridade das gravações, Garantir sincronização correta entre abas e gravações, Não permitir gravação sem aba ativa, Garantir anonimato do usuário, Enviar dados de eventos sem impactar UX, Manter integridade dos dados enviados, Renderizar Popup no container correto, Aplicar estilos globais e temáticos sem conflito, Gerar seletores únicos e válidos, Manter performance aceitável, Evitar seletores ambíguos, Gerar scripts válidos para Cypress, Respeitar timing entre ações, Manter integridade das ações stateful, Seletores devem ser únicos e estáveis, IDs inválidos não devem ser usados, Priorizar atributos de acessibilidade e testes, Importação correta e tipada de arquivos estáticos para evitar erros de build, Garantir que chamadas à API do navegador sejam compatíveis entre Chrome e Firefox, Integridade dos dados de ações, Validação de tipos de ações suportadas, Captura precisa de eventos temporais, Garantir tipagem estrita para evitar erros em runtime, Manter compatibilidade com ES5 para browsers legados, Build deve ser executado em modo produção, Erros de build devem ser reportados e impedir deploy, NODE_ENV deve sempre estar definido, PORT deve ser um número válido, Hot Module Replacement must be enabled for dev mode, Dev server must serve assets with CORS headers, Não versionar arquivos de dependências, Não expor arquivos de configuração sensíveis, Manter repositório limpo e organizado, All actions must have valid, non-negative, and sequential timestamps, Scripts gerados devem refletir fielmente ações do usuário, Comandos Cypress devem ser válidos e executáveis, Gravação precisa das ações do usuário, Geração correta do código Cypress, Isolamento do contexto do navegador, Consistent visual feedback on interactive elements, Accessibility compliance, Responsive layout support, Garantir integridade e fidelidade do código gerado a partir das ações, Não permitir replay de gravações sem ações, Manter sincronização correta do estado do replay e UI, Evitar perda de dados durante cópia e download do código, Não permitir exclusão sem confirmação do usuário, Garantir integridade dos dados durante importação e exportação, Manter ordenação e filtros consistentes após operações, Notificar usuário sobre sucesso ou falha em operações críticas, Consistent UI layout, Accessible typography, Responsive scrolling behavior, Gravações vazias não podem ser salvas, IDs de gravação devem ser únicos, Importação deve validar formato e evitar duplicatas, Limite máximo de entradas no histórico não pode ser ultrapassado sem poda, Integridade dos dados de gravação deve ser mantida, Migração de dados antigos deve preservar ações, Garantir unicidade do ID da gravação, Manter integridade temporal (startedAt &lt; endedAt), Limitar número máximo de gravações conforme configuração, Preservar ações e código gerado para reprodutibilidade, Consistent dark mode application, Accessibility compliance for color contrast, Manter identidade visual consistente, Garantir acessibilidade e responsividade, Consistência visual do tema dark, Responsividade do layout, Acessibilidade mínima via contraste, Consistência visual entre views, Navegação clara com botão de voltar, Consistência visual do tema Dark, Feedback visual claro para interações, Acessibilidade mínima para leitura e navegação, Consistência visual entre temas, Legibilidade e acessibilidade, Feedback visual claro para ações do usuário, Consistência visual do tema, Acessibilidade básica para navegação, Manter integridade visual e responsividade, Garantir acessibilidade e usabilidade, Preservar estados de seleção e ações do usuário, Nomes de arquivos devem ser válidos para sistemas de arquivos, Downloads devem ser disparados sem falhas, Conteúdo exportado deve refletir o código gerado, Não truncar textos menores que o limite, Preservar domínio completo em URLs truncadas, Manter alta legibilidade e usabilidade em tema dark, Garantir responsividade e acessibilidade em múltiplos dispositivos, Exibir estados de erro e carregamento de forma clara e distinta, Preservar consistência visual e interatividade dos botões e abas, Manter integridade visual e responsiva, Garantir feedback visual claro para ações do usuário, Preservar usabilidade em dispositivos móveis, Manter consistência visual do tema dark, Garantir legibilidade e acessibilidade, Manter alto contraste para acessibilidade, Consistência visual em todos os componentes, Compatibilidade com resolução 800x600, Validação rigorosa de dados, Consistência transacional, Controle de acesso baseado em roles, Garantir sincronização correta entre estado do replay e aba ativa, Não permitir múltiplos replays simultâneos na mesma aba, Gerenciar erros de comunicação com background script de forma robusta, Replay deve ser consistente e sincronizado, Tipos devem garantir integridade dos dados, Garantir que o estado do replay seja corretamente sincronizado entre abas e popup, Não permitir execução de replay sem gravação válida, Limpar estado após conclusão para evitar vazamento de memória, Manter comunicação assíncrona confiável entre componentes, Execução fiel e sequencial das ações gravadas, Garantir que ações só sejam consideradas concluídas após sucesso comprovado, Manter integridade do estado da página durante replay, Não interromper o fluxo sem notificação clara de erro, Garantir integridade do estado do replay durante execução, Não perder dados de passos completados, Manter consistência entre mensagens de status e estado interno, Sanitização de URLs para evitar XSS, Validação de parâmetros de viewport, Garantir presença de comandos para exportação</critical_business_rules>
  </project_metadata>
  <technical_stack>
    <primary_language>JavaScript ES6+, JSX, JavaScript, Node.js, TypeScript 5.0, TypeScript 5.x, TypeScript 4.1.5, Manifest Version 2, JavaScript ES2021, Manifest V3 JSON, TypeScript 4.x, React 18, JavaScript (Node.js 16+), JavaScript (Node.js 18+), JavaScript ES2020+, CSS3, JavaScript (React integration), CSS Variables, CSS Custom Properties (CSS Variables), JavaScript ES2022, Node.js 18, JavaScript ES Modules, TypeScript (tipos)</primary_language>
    <frameworks>React (via react-app preset), Webpack, Babel, Webpack 5, Yarn, Cypress, Playwright, Puppeteer, Jest 29.x, ts-jest, React 17.0.1, Jest 27.3.1, Webpack 5.23.0, Babel 7.12.17, Chrome Extensions API, Nenhum framework frontend explícito, React 18.2, React 18, Cypress (para geração de código de teste), React 18.x, WebExtensions API (compatibilidade com Firefox), Lodash 4.x, FontAwesome 6.x, ReactDOM, Nenhum framework front-end explícito (vanilla JS/TS), Uso de biblioteca lodash.debounce para otimização de eventos, FontAwesome SVG Core, Nenhum framework específico detectado, Nenhum (biblioteca standalone), Cypress 12.x, React 18.2 (implícito), Cypress (para automação de testes), Webpack 5.x, WebpackDevServer 4, Jest 29, Playwright 1.x, None (Vanilla CSS), FontAwesome 6 (free-solid-svg-icons), react-syntax-highlighter v15+, Nenhum framework frontend/backend explícito, Node.js 20.x, Nenhum framework CSS explícito, Possível integração com React ou similar, Possível integração com React ou similar para componentes, React (suposição pelo padrão de classes e estrutura), Possível integração com React ou Vue para JS, Nenhum framework CSS explícito, uso de variáveis CSS customizadas, Cypress (para testes e geração de código), Possível integração com React 18.x (baseado em classes e nomenclatura CSS modular), React (presumido), CSS Modules or Styled Components (possível integração), Nenhum framework específico declarado, Express 4.18.2, Mongoose 6.7.0, ES Modules, React 18.2 (presumido frontend), Node.js 20 (presumido backend), Cypress (para testes end-to-end)</frameworks>
    <databases>chrome.storage.local, Não aplicável, IndexedDB (implícito via RecordingService para persistência local), chrome.storage.local (armazenamento local do navegador), Armazenamento local do navegador (chrome.storage.local), LocalStorage (via recordingStore), Não aplicável (frontend client-side), Não aplicável (armazenamento local via RecordingService abstraído), recordingStore (abstração de storage, tipo não especificado), Nenhum banco de dados explícito (persistência pode ser via filesystem ou storage customizado), MongoDB 6.0, IndexedDB (via recordingStore abstraction)</databases>
    <external_services>Chrome Web Store, Firefox Add-ons Marketplace, GitHub Actions, Browser APIs (chrome.*), Test Automation Frameworks (Cypress, Playwright, Puppeteer), https://*.deploysentinel.com, Chrome WebExtensions API, Chrome Extension API, DeploySentinel Webapp, Chrome Tabs API, Chrome Runtime Messaging, chrome.storage API, APIs do navegador Chrome e Firefox para tabs, scripting e webNavigation, Chrome Storage API, API chrome.runtime para comunicação com background scripts, Chrome Extension Messaging API, Chrome Extension APIs (tabs, scripting), FontAwesome Icons, Google Analytics Measurement Protocol API, @fortawesome/fontawesome-svg-core, TemplateRenderer (módulo interno para geração de templates), Firefox WebExtension API, Cypress Test Runner, Chrome Extensions API, Chromium Browser, Hooks internos (useReplay) para controle de replay, Clipboard API via react-copy-to-clipboard, RecordingService (API interna para listagem, remoção, importação e exportação de gravações), Google Fonts (Roboto), Nenhum serviço externo diretamente referenciado, Font icon libraries (ex: FontAwesome), Browser Web APIs (Blob, URL, DOM), File system APIs para import/export JSON (via browser), REST APIs externas para autenticação e notificações, Chrome Extensions API (runtime, tabs), replay-runner (script injetado externamente), Chrome Runtime Messaging API, Chrome Scripting API, Browser APIs (Cache Storage), Possível integração com sistemas de gravação externos</external_services>
    <package_manager>npm, yarn, Yarn, yarn 1.22.22, npm ou yarn (comum em projetos front-end React), npm 9.6.7</package_manager>
  </technical_stack>
  <architecture_patterns>
    <design_pattern>Modular Build Configuration, Pipeline, Modular Build Scripts, Observer Pattern, Event-driven Architecture, Modular Architecture, Configuration Object Pattern, Modular, Component-based UI, Build Pipeline Orchestration via npm scripts, Extension Architecture (Background Script, Content Script, Browser Action), Modular Extension Design, Service Worker Background Processing, Modularization, Message Passing, Component-Based Architecture, Presentational Component, Service Layer (RecordingService), Event-driven Communication (chrome.runtime.sendMessage), Hooks Pattern, Modularização funcional com separação clara entre manipulação de estado e execução de scripts, Presentational and Container Components, Separation of Concerns, Observer Pattern (event listeners), State Management via React Hooks, Functional Components, Singleton, Shadow DOM encapsulation, Observer pattern para escuta e reação a eventos DOM, Singleton-like pattern para instância única do Recorder, Event-driven architecture para captura e processamento de ações, Hook Pattern, Hooks for State Management, Container/Presenter Pattern, Modularização funcional, Hot Module Replacement, Modular Functional, Generator Pattern, Bottom-up Search, Builder Pattern (ScriptBuilder abstrato e implementações concretas), Factory Method (createTemplateRenderer), Modularização Funcional, Defensive Programming, Modularização via declaração de módulos TypeScript, Alias Pattern, Inheritance, Discriminated Union Types, Component-based, Build Pipeline Script, Configuration Module Pattern, Modular Configuration, Middleware Pattern, .gitignore pattern segmentation, Functional Programming, Modular Design, Builder Pattern, Fluent Interface, Test Automation Pattern, Page Object Pattern (implicit), Atomic Design (Component-based CSS), Hook Pattern para estado e efeitos, Separation of Concerns entre UI, lógica de replay e geração de código, Service Layer Abstraction, Modular CSS, Theming with CSS Variables, Service Facade, Modularização, Strategy (para pruneStrategy), Interface Segregation, Repository Pattern (IHistoryBackend abstrai persistência), DTO (Data Transfer Object) para RecordingEntry, Component-based UI Styling, Theming via CSS Variables, Component-Based UI, Container/Presenter, Component Composition, Component-based styling, BEM-like naming, Component-based UI styling, Component-Based UI Styling, Responsive Design, Interface para tipagem clara, Utility Module, CSS Modular / BEM-like naming conventions, BEM CSS Naming, Global Style Reset, MVC, Repository Pattern, Hook Pattern (React), Observer Pattern (event listeners), Command Pattern (mensagens para background), Barrel Module, Dependency Injection, Observer (event listeners), Pub-Sub via chrome.runtime messaging, Observer Pattern (MutationObserver), Retry Pattern, Event-driven architecture, Message passing, State machine pattern, Factory Pattern (createTemplateRenderer), Modularização por responsabilidade</design_pattern>
    <folder_structure>Config files in root or config folder, Source code in src/, src/, build/, dist/, src/ - código fonte, assets/ - imagens e ícones, tests/ - testes E2E, dist/ - builds para Chrome e Firefox, Configurações centralizadas em pasta de configuração (ex: /config ou raiz), build - arquivos empacotados, utils - scripts utilitários para build e servidor, node_modules - dependências, src - código fonte React e lógica, background/ - scripts de background, content_scripts/ - scripts injetados nas páginas, popup/ - interface do usuário da extensão, assets/ - ícones e recursos estáticos, background/ - service worker scripts, popup/ - UI da extensão, assets/ - ícones e imagens, Common/utils - utilitários compartilhados, storage - gerenciamento de estado, modules/replay - lógica de replay, background - script principal da extensão, src/: código fonte, background/: scripts da extensão, content-scripts/: scripts injetados, src/components/Icon - componente isolado para reutilização visual, pages: componentes de tela, Popup: componentes modais ou popups, assets: arquivos estáticos como imagens e SVGs, src/components - componentes React reutilizáveis, src/types - definições de tipos TypeScript, utils/: funções utilitárias para manipulação de storage, builders/: geração de código (ex: genCypressCode), storage/: serviços de persistência (RecordingService), types/: definições de tipos e interfaces, src/hooks - custom React hooks, src/utils - funções utilitárias para armazenamento, src/types - definições de tipos e constantes, src/ - código fonte principal, src/storage/ - funções de manipulação de armazenamento local, src/scripts/ - scripts executados nas abas, src/utils/ - utilitários e helpers, types/ - definição de tipos e enums, builders/ - funções auxiliares para construção de seletores, components/ - componentes React reutilizáveis, styles/ - arquivos CSS, src/components - UI components, src/builders - lógica de geração de código, src/types - definições de tipos, /components - UI components, /builders - lógica de geração de seletores e código, /Common - hooks e utilitários compartilhados, /types - definições de tipos, src/components/Highlighter - componente visual e estilização associada, ./ControlBar - componente React principal, ../Common - estilos compartilhados, root - script de bootstrap e injeção, builders/selector - geração de seletores CSS para elementos, Common/utils - funções utilitárias como acesso ao localStorage, types - definições de tipos e enums para ações e eventos, main recorder module - captura e gerenciamento dos eventos, Common: componentes e hooks reutilizáveis, types: definições de tipos TypeScript, styles: CSS modularizados, Common (shared components/utilities), Content (content scripts and UI parts), storage (state persistence), builders (code generation), types (TypeScript types), Common/utils para funções utilitárias, Módulo de analytics separado para eventos, src/: código fonte principal, src/components/: componentes React reutilizáveis, src/themes/: estilos temáticos, src/global.css: estilos globais, test/ - testes unitários, dist/ - build final, types/ - definições de tipos e enums, generators/template/ - renderização de templates, core/ - lógica principal de geração de scripts, src/types - Tipos e enums, src/utils - Funções utilitárias como finder, src/selectors - Geração e seleção de seletores, src/assets para arquivos estáticos, src/types para declarações de tipos, types/: definições de tipos, dist/: build final, src/actions - definição das ações e tipos, src/utils - funções utilitárias (planejado), src (código fonte), build (artefatos compilados), node_modules (dependências externas), config/ - configurações do Webpack, scripts/ - scripts de build e automação, config/ - arquivos de configuração centralizados, config/ - configurações do Webpack e ambiente, build/ - saída dos arquivos compilados, src/ - código fonte da aplicação, /node_modules para dependências, /coverage para relatórios de teste, /build para artefatos de produção, .prompts, .logs, .audios para dados auxiliares, src/types - definição de tipos, src/utils - funções utilitárias para manipulação de dados, src/pages/builders - Contém construtores de scripts Cypress, tests/ - Contém testes unitários, /tests - testes automatizados, /build - extensão compilada, /tmp - dados temporários para contexto do navegador, styles/components - componentes reutilizáveis, styles/utilities - classes utilitárias para layout e espaçamento, hooks/ - hooks customizados para lógica de negócio, types/ - definições de tipos TypeScript, utils/ - funções utilitárias para manipulação de texto e download, themes/ - estilos globais e temas CSS, src/storage - serviços de persistência e manipulação de dados, src/Common/utils - funções utilitárias, styles/ - arquivos CSS base e componentes, assets/ - fontes e imagens, /builders - geração de código, /services - lógica de negócio e abstração de storage, src/store - gerenciamento de estado e persistência, src/actions - definição de ações do usuário, src/interfaces/ - definições de tipos e contratos, src/backend/ - implementações de persistência, src/actions/ - definição e manipulação de ações gravadas, styles/: arquivos CSS globais e temáticos, components/: componentes React com estilos associados, src/components - componentes reutilizáveis de UI, themes/ - arquivos de tema, layout/ - componentes de layout, src/assets - arquivos estáticos como imagens e SVGs, src/styles - arquivos CSS globais e modulares, Estilos organizados por componente (ex: recording-history-table, action-buttons, tabs), styles/components/recordingDetail - CSS modular para componentes específicos, Estilos organizados por componente UI, Separação clara entre header, toolbar, content e tabela, Estilos organizados por contexto: history, detail, modern variants, src/utils - funções utilitárias para download e manipulação de arquivos, src/interfaces - definições de tipos e interfaces, src/utils - funções utilitárias para manipulação de dados e strings, src/components/RecordingDetail - componente e estilos relacionados, src/assets - variáveis CSS e temas, src/utils - helpers para animações e responsividade, /components/recordingHistory - Componentes visuais e lógicos, /styles - Estilos globais e variáveis CSS, Estilos globais em pasta /styles, Componentes UI em /components, Não aplicável - arquivo CSS único para tema, controllers para lógica de entrada, models para definição de dados, services para regras de negócio, routes para endpoints, src/hooks - hooks customizados como useReplay, src/background - scripts de background da extensão, src/components - componentes React UI, Módulos organizados por funcionalidade, Separação entre handlers e tipos, pages/ - funcionalidades específicas da UI e armazenamento, storage/ - abstrações para persistência local, handlers/ - lógica central de controle e coordenação, pages/types - Definições de tipos e interfaces, types/replay - Tipos específicos para replay, modules/replayRunner - Implementação do módulo de execução de ações, pages/types - definição de tipos compartilhados, modules/replay - lógica e tipos do sistema de replay, components - UI para controle e visualização do replay, src/TemplateRenderer - lógica de geração de templates, tests/ - testes unitários e de integração</folder_structure>
    <naming_conventions>camelCase for variables and functions, PascalCase for React components, camelCase para funções, kebab-case para arquivos, CamelCase para classes e funções, prefixos claros para eventos e handlers, camelCase para variáveis e propriedades, PascalCase para tipos e interfaces, camelCase para variáveis e funções, PascalCase para componentes React, snake-case para scripts e arquivos zip, PascalCase para classes, nomes descritivos para scripts e arquivos, PascalCase para componentes UI, snake_case para arquivos de configuração, camelCase para funções e variáveis, PascalCase para classes e stores, constantes em UPPER_SNAKE_CASE, camelCase para props e variáveis, snake-case para arquivos estáticos, PascalCase para componentes, camelCase para props e funções, CamelCase para funções e classes, snake_case para variáveis locais, PascalCase para tipos e componentes, prefixo use para hooks, Funções em camelCase, Constantes em camelCase, Arquivos em kebab-case, UPPER_SNAKE_CASE para enums, Arquivos com extensão .tsx para componentes, CamelCase para componentes e funções, PascalCase para tipos e enums, kebab-case para arquivos CSS, kebab-case para IDs CSS, snake_case para variáveis globais no window, snake_case para variáveis locais e parâmetros, Prefixo _ para propriedades privadas, Enums e tipos com PascalCase, CamelCase para funções e componentes, kebab-case para classes CSS, PascalCase for Components, camelCase for functions and variables, Uppercase enums (ActionsMode, ScriptType), Constantes em maiúsculas com underscore, CamelCase para componentes React, CamelCase para classes, UPPER_SNAKE_CASE para constantes, prefixo gen para funções geradoras, Extensões de arquivos mantidas (.css, .svg), Declarações em arquivos .d.ts, PascalCase para classes e interfaces, PascalCase para classes e enums, camelCase para propriedades e funções, PascalCase para componentes React e classes, Variáveis em UPPER_SNAKE_CASE para env vars, Módulos em camelCase ou kebab-case, PascalCase para classes e plugins, kebab-case para arquivos e pastas, Arquivos .env para configurações locais, secrets.*.js para arquivos sensíveis, PascalCase para tipos e classes, testes nomeados com descrições claras, BEM-like for components (.btn-primary), Utility-first for helpers (.p-1, .d-flex), prefixo &apos;handle&apos; para funções de eventos, Prefixo &apos;handle&apos; para callbacks de eventos, Sufixo &apos;Btn&apos; para botões, BEM (Block Element Modifier) recomendado para classes adicionais, CamelCase para classes e métodos, IDs formatados como hostname:data_hora_sufixo, CamelCase para classes e interfaces, camelCase para métodos e variáveis, Constantes em UPPER_SNAKE_CASE, CamelCase para interfaces e classes, camelCase para propriedades e métodos, BEM-like CSS classes, camelCase para variáveis JS, BEM-like para classes CSS, prefixo layout- para containers principais, BEM-like class names, Uso de prefixos para componentes (ex: recording-detail, action-list), BEM-like: .modern-recording-detail, .modern-detail-header, .modern-tab, Classes com prefixo &apos;modern-&apos; para escopo, Uso de nomes descritivos e BEM-like, BEM-like classes, Prefixos para contexto (.recording-, .modern-), PascalCase para interfaces, snake_case para nomes sanitizados de arquivos, Prefixo &apos;recording-detail&apos; para classes CSS, Uso de kebab-case para classes, Variáveis CSS customizadas com prefixo &apos;--&apos;, BEM para classes CSS, camelCase para variáveis JS/TS, IDs para containers principais (#app-container), Variáveis CSS com prefixo --, BEM-like classes (.btn-primary, .ds-dark), CSS variables com prefixo -- para organização, snake_case para arquivos, CamelCase para funções e variáveis, PascalCase para interfaces e tipos, Prefixo &apos;use&apos; para hooks customizados, Classes em PascalCase (ReplayHandler), Métodos e variáveis em camelCase, snake_case evitado, Prefixo execute para funções de ação, Enums em PascalCase com prefixo Replay, Interfaces iniciadas com I ou nome descritivo (ReplayState, ReplayRequest), Tipos e mensagens com sufixo Message ou State</naming_conventions>
    <module_boundaries>Separation between config and source code, Plugins isolated from presets, separação clara entre código fonte e artefatos gerados, Separação clara entre captura de eventos, geração de scripts e UI da extensão, Módulos independentes para Chrome e Firefox, Configuração isolada e exportada para uso pelo Jest, Separação clara entre código fonte e scripts de build, Dependências isoladas entre devDependencies e dependencies, Separação clara entre background scripts, content scripts e UI (popup), Comunicação via mensagens entre scripts, Separação clara entre background, content scripts e UI popup, Comunicação via mensagens e eventos, Separa utilitários, armazenamento e replay em módulos distintos, Comunicação via import/export e mensagens assíncronas, Separação clara entre código da extensão e código do webapp, Comunicação via mensagens, Componentes isolados sem dependências externas além do React, Separação clara entre componentes visuais e assets estáticos, Importação relativa para recursos locais, Separação clara entre tipos e componentes, Componentes isolados sem estado global, Separa lógica de persistência, geração de código e manipulação de storage em módulos distintos, Comunicação entre módulos via import/export e mensagens do runtime, Separação clara entre hooks, utilitários e tipos, Dependência unidirecional dos hooks para utils e types, Módulos separados por responsabilidade: armazenamento, execução de scripts, manipulação de abas, Separação clara entre tipos, builders e componentes, Dependência unidirecional de tipos para componentes, Separação clara entre UI (components) e lógica de negócio (builders), Tipos compartilhados via pasta types, UI components isolados de lógica de geração de código, Hooks e utilitários em Common, Builders para lógica de seleção e código, Isolamento do componente Highlighter com importação explícita de estilos, Separação clara entre UI (ControlBar) e bootstrap script, Isolamento via shadow DOM para evitar poluição global, Recorder encapsula toda lógica de captura e armazenamento, Utils e builders são módulos auxiliares desacoplados, Comunicação com background via chrome.runtime é isolada, Separação clara entre UI (TriggerButton) e lógica de gravação (hooks, endRecording), UI components separated por funcionalidade, Hooks encapsulam lógica de estado, Builders isolam geração de código, Storage abstrai persistência, Módulo analytics isolado, dependente apenas de utils externos, Separação clara entre componentes e estilos, Importação explícita de estilos por componente, Separação clara entre funções utilitárias, lógica de busca e otimização, Separação clara entre tipos, geração de scripts e renderização de templates, Dependência unidirecional do builder para o renderer, Separação clara entre tipos, utilitários e lógica de seleção, Dependência unidirecional para evitar acoplamento, Separação clara entre código TypeScript e assets estáticos via módulos declarados, Separação clara entre módulos de compatibilidade e lógica de negócio, Separação clara entre tipos (enums, classes) e lógica utilitária, Separação clara entre código fonte e build, Resolução de módulos via Node.js, Separação clara entre configuração (webpack.config.js) e execução (build script), Módulo isolado para configuração, sem dependências externas, Separação clara entre configuração (config) e execução (server), Dependência unidirecional do servidor para configuração, Separação clara entre código fonte e artefatos gerados, Separação clara entre tipos e funções utilitárias, Dependência unidirecional de tipos para funções, Separação clara entre lógica de construção de scripts e testes, Mocks usados para isolar dependências, Separação clara entre testes e código da extensão, Uso de imports explícitos para Playwright e Jest, Separação clara entre componentes visuais e utilitários CSS, Componentes isolados por funcionalidade, Hooks encapsulam lógica de replay, Utils desacoplados para reutilização, Componentes isolados com props para comunicação, Serviços externos acessados via importação explícita, Separação clara entre UI e lógica de dados, Separação clara entre estilos globais e componentes específicos, Separação clara entre tipos, builders e serviços, recordingStore encapsula persistência, Separação clara entre tipos, store e ações, Dependência unidirecional do store para tipos e chrome API, Separação clara entre definição de tipos (interfaces) e implementação, Backend isolado via interface para permitir múltiplas implementações, Separação clara entre lógica React e estilos CSS, Importação de temas via index.jsx, Componentes isolados sem dependências internas complexas, Separação clara entre tema e layout, Estilos específicos para views distintas, Componentes isolados com props explícitas, Separação clara entre lógica e apresentação, Estilos isolados por componente para evitar vazamento de CSS, Separação clara entre containers, cabeçalhos, conteúdo e ações, Estilos isolados para RecordingHistory, Dependência de variáveis CSS globais, Separação clara entre estilos de histórico e detalhes, Modularidade visual para componentes reutilizáveis, Separação clara entre preparação de dados (createTestFilename, prepareTestDownload) e execução do download (downloadTestFile), Módulo isolado sem dependências externas, exporta funções puras, Estilos isolados para o componente RecordingDetail, Separação clara entre header, content, toolbar e views, Separação clara entre estilos e lógica funcional, Isolamento do componente RecordingHistory, Separação clara entre estilos globais e específicos do popup, Isolamento do tema via classe raiz .ds-dark, Separação clara entre camada de dados, lógica de negócio e interface, Separação clara entre UI (React components/hooks) e lógica de background (background scripts), Comunicação via mensagens assíncronas, Replay handler isolado, Tipos compartilhados via exportação central, Separação clara entre armazenamento (recordingStore) e lógica de replay, Comunicação via mensagens entre background, popup e content scripts, Isolamento do handler como singleton para estado centralizado, ReplayRunner isolado para execução de ações, Comunicação via mensagens com background script, Tipos compartilhados importados de módulos centrais, Replay module isolado para lógica de replay, Comunicação via mensagens tipadas entre módulos, Separação clara entre estado, mensagens e execução de ações</module_boundaries>
  </architecture_patterns>
  <code_standards>
    <style_guide>Airbnb JavaScript Style Guide, Airbnb JavaScript Style Guide adaptado para TypeScript, Airbnb TypeScript Style Guide, Airbnb JavaScript Style Guide (implícito via eslint-config-react-app), Airbnb JavaScript/TypeScript Style Guide, Airbnb TypeScript Style Guide (implícito), Airbnb JavaScript Style Guide (implícito), CSS standard conventions, CSS Standard Style Guide, TypeScript ESLint Recommended, Airbnb JavaScript Style Guide para React, CSS Standard, Uso consistente de variáveis CSS, CSS padrão com variáveis CSS para temas, CSS3 com uso de variáveis CSS, CSS padrão, uso consistente de variáveis CSS, CSS moderno com variáveis e flexbox/grid, Uso consistente de nomenclatura e organização, Guia de estilo CSS moderno com variáveis e flexbox, Uso consistente de espaçamentos e cores via variáveis, CSS Standard Practices, BEM Methodology, CSS3 standard, CSS moderno com variáveis, comentários claros</style_guide>
    <linting_rules>ESLint with React plugin, extends react-app, globals chrome readonly, .eslintrc.json, ESLint com regras para TypeScript, Regras para evitar any e garantir tipagem forte, eslint com plugins para React, JSX Accessibility, import e hooks, .eslintrc.json com regras para ES6, browser, node, .eslintrc.json com regras para ES2021 e ambiente browser, Proibição de any implícito, Regras para async/await, .eslintrc.json com regras para TypeScript e JS, ESLint com regras padrão React, .eslintrc.js com regras para React e JSX, ESLint com regras padrão Airbnb, .eslintrc.json com regras para TypeScript, incluindo checagem de tipos e estilo, ESLint com regras para React e TypeScript, ESLint com regras para evitar uso de any, garantir async/await correto e evitar callbacks aninhados, .eslintrc.json com regras para React e TypeScript, ESLint com regras para evitar duplicidade e garantir tipagem, ESLint com regras padrão para TypeScript, Proibição de any explícito, Uso de strict null checks, Proibição de catch vazio sem tratamento, ESLint com regras para importação de módulos estáticos, .eslintrc.json com regras para TypeScript e compatibilidade ES6, skipLibCheck:true para ignorar checagem de libs externas, strict:true para checagem rigorosa, .eslintrc.json com regras para ES6+, .eslintrc.json com regras para ES6+, node environment, Sem uso de any exceto em mocks, Possível uso de stylelint com regras para propriedades e ordem, .eslintrc.json com regras para React, TypeScript, hooks e acessibilidade, ESLint com regras para React e TypeScript, incluindo regras de acessibilidade e melhores práticas, stylelint com regras padrão para CSS3, ESLint com regras para async/await, uso de tipos, e tratamento de erros, Regras padrão ESLint para TypeScript, Sem regras customizadas explícitas no código, Regras para evitar any implícito e garantir tipagem estrita, stylelint para CSS, eslint para JS/React, Possível uso de stylelint com regras para variáveis e propriedades, Não especificado no código, Regras para evitar side effects em funções puras, stylelint com regras para evitar !important e garantir consistência, stylelint com regras para CSS moderno e variáveis, Não especificado, .eslintrc.json com regras para evitar any, uso de const, e indentação de 2 espaços, ESLint com regras para TypeScript, incluindo no-unused-vars, strict typing, ESLint com regras para async/await, no-explicit-any, e uso estrito de tipos, ESLint com regras para TypeScript, sem uso de any, preferências para readonly</linting_rules>
    <formatting>Prettier, singleQuote: true, trailingComma: es5, printWidth: 80, proseWrap: always, arrowParens: always, Prettier com configuração padrão para TypeScript, Prettier com configuração padrão, Prettier com configuração padrão via lint-staged, Prettier com configuração padrão para JavaScript, Prettier com configuração padrão para React, Prettier com configuração padrão para 2 espaços e aspas simples, Prettier com configuração padrão para React/TypeScript, Prettier para formatação automática com padrão de 2 espaços, Prettier com configuração padrão para projetos React, Prettier com configuração padrão para TypeScript e React, Consistent indentation and spacing, Prettier com configuração padrão para 2 espaços, aspas simples, Prettier com configuração padrão para espaçamento, aspas simples e ponto e vírgula, Prettier para CSS, Prettier com configuração padrão para CSS e JS, Indentação de 2 espaços, Quebra de linha após blocos, Indentação consistente, Uso de comentários para seções, Uso de espaços para alinhamento, Uso de espaços para separação, Prettier configurado para CSS com indentação de 2 espaços, Indentação consistente, uso de comentários para seções, Prettier com configuração padrão, max-len 100, Prettier com configuração padrão para espaçamento e aspas simples</formatting>
    <documentation_style>JSDoc, JSDoc para funções e classes principais, JSDoc para funções e tipos, JSDoc para funções e componentes React, JSDoc para funções e módulos, JSDoc para funções e métodos públicos, Comentários inline simples, sem JSDoc explícito, JSDoc para funções e componentes, JSDoc para comentários de funções e componentes, JSDoc para funções e hooks, JSDoc para funções públicas e complexas, JSDoc para funções e interfaces, JSDoc para documentação inline de funções e classes, Comentários inline e JSDoc para funções principais, JSDoc para documentação de funções e componentes, JSDoc para funções públicas, JSDoc para funções públicas e classes, JSDoc para declarações de tipos, Comentários JSDoc (a serem implementados), JSDoc para documentação inline, Inline comments para propriedades específicas, JSDoc para funções e componentes principais, Comentários CSS padrão, JSDoc para métodos públicos e classes, JSDoc para documentação de métodos e classes, Comentários CSS inline, JSDoc para componentes React, JSDoc para comentários de componentes, Comentários em português explicativos, Comentários CSS simples para seções, Comentários simples para seções, Comentários mínimos, apenas cabeçalho do arquivo, Comentários em português explicando blocos principais, Comentários CSS explicativos para seções e blocos, Comentários em português para contexto, JSDoc para funções e classes, JSDoc para funções públicas e tipos complexos</documentation_style>
    <type_checking>TypeScript optional, not explicit here, TypeScript strict mode, Strict TypeScript, TypeScript com tipagens estritas para React e APIs de browser, Nenhum type checking explícito (JavaScript puro), JavaScript sem tipagem estática, Possível uso futuro de TypeScript, Sem uso de any implícito, PropTypes ou TypeScript (não aplicável neste arquivo), Strict TypeScript (strict mode habilitado), Strict TypeScript com tipagem explícita para funções assíncronas e objetos, Strict TypeScript typings, Strict TypeScript com tipagem explícita para eventos e ações, Strict TypeScript com checagem completa, Strict TypeScript enabled, PropTypes para validação de props React, Sem TypeScript, Strict TypeScript (noImplicitAny, strictNullChecks), Uso extensivo de tipos e interfaces, strict TypeScript com exceção para strictPropertyInitialization:false, Nenhum (JavaScript puro), Strict TypeScript com tipos explícitos para props e estados, Strict TypeScript com tipagem explícita para props e estados, Strict TypeScript com tipagem explícita em métodos públicos, Strict TypeScript com tipos explícitos, TypeScript strict mode para React, Strict TypeScript (strict mode ativado), Não aplicável para CSS, TypeScript strict mode desativado, uso parcial de tipagem, Strict TypeScript com tipos explícitos e interfaces, Strict TypeScript com tipos explícitos para mensagens e estados</type_checking>
  </code_standards>
  <testing_strategy>
    <test_framework>Jest, Playwright Test Runner, Jest 29.x, Jest 27.3.1, Jest para testes unitários do background e scripts, Jest 29, React Testing Library, Não detectado no código fornecido, Cypress (para testes end-to-end), Jest 29 (implícito para front-end), Jest 29 (provável), Jest 29 com React Testing Library, Não especificado no código fornecido, Jest 29 para testes unitários de componentes React associados, Jest (para lógica JS/TS associada)</test_framework>
    <test_structure>__tests__ folders or *.test.js files, tests/ unitários e integração, tests/e2e/ para testes end-to-end, tests/unit/ para testes unitários, Testes localizados em pasta __tests__ ou arquivos *.test.ts, Testes localizados em pastas __tests__ e arquivos *.test.js/ts, tests/ para testes unitários e integração, Testes localizados em pasta __tests__ correlata aos módulos, tests/unit/, tests/integration/, Testes localizados em __tests__ ou pasta components/__tests__, Testes localizados em __tests__ ou pasta __specs__ ao lado do componente, tests/unit para testes unitários, tests/components para testes de componentes React, Testes unitários localizados em __tests__ próximos aos módulos, Testes de integração para serviços de gravação, tests/hooks - testes unitários para hooks, Testes localizados em __tests__ próximos aos módulos correspondentes, __tests__ folders próximos aos componentes, Testes unitários para renderização e lógica condicional, Testes unitários para builders e componentes, Testes localizados próximos aos componentes, Mocks para APIs e eventos DOM, __tests__ folder ao lado do componente, Testes localizados em __tests__ próximos aos componentes, Testes de integração para simulação de eventos DOM, Testes localizados em pasta __tests__ ao lado dos componentes, __tests__ folders next to components, Unit and integration tests, tests/ unitários e de integração próximos aos componentes, test/unit para testes unitários, test/integration para testes de integração, Testes organizados em arquivos separados por feature, Uso de describe/it para estruturação, Testes unitários em pasta __tests__ ao lado dos módulos, Testes localizados em __tests__ ou pasta tests, tests/unit para testes de classes e funções, tests/ localizados paralelamente ao código fonte, /coverage para relatórios de teste, tests/utils - testes unitários para funções utilitárias, Testes organizados por describe e test, Mocks e spies para isolamento, Testes organizados em blocos beforeAll, afterAll e test, Uso de async/await para controle assíncrono, Testes unitários e de integração para UI e hooks, Testes localizados em /tests/services, Testes unitários para métodos do RecordingService, Não especificado, Testes localizados em __tests__ próximos aos módulos, Testes unitários para interfaces e implementações backend, tests/integration para testes de integração, Testes localizados em __tests__ dentro da pasta components, Testes unitários para funções utilitárias em src/utils/__tests__, Testes localizados em src/components/RecordingDetail/__tests__, /tests/unit para testes de componentes e estilos, Testes localizados em __tests__ próximos aos hooks e componentes, Testes localizados próximos aos módulos, Testes unitários localizados em __tests__ próximos aos handlers, Testes unitários para funções executeClick, executeType, executeNavigate, Testes localizados em __tests__ dentro do módulo replay</test_structure>
    <coverage_requirements>Minimum 80% coverage, &gt;= 80%, Cobertura mínima de 80%, Cobertura mínima não especificada, mas jest --coverage configurado, &gt;= 80% cobertura, Cobertura mínima de 80% para componentes visuais, Cobertura mínima de 85%, Cobertura mínima de 80% para funções críticas de armazenamento e execução, Cobertura mínima de 85% para lógica crítica, Cobertura mínima de 80% para componentes UI e hooks, &gt;80% coverage, Cobertura mínima de 90%, Cobertura focada em fluxos críticos de UI, &gt;= 90% cobertura para funções críticas, Cobertura focada em funcionalidades críticas da extensão, Cobertura mínima de 80% para componentes críticos, Cobertura mínima de 80% para componentes e serviços, Cobertura mínima de 80% para serviços críticos, Não especificado, &gt;= 80% coverage, Cobertura mínima de 90% para funções críticas, Cobertura mínima de 90% para funções utilitárias, Cobertura mínima de 80% para componentes visuais e interações, Cobertura mínima de 80% para hooks e lógica crítica, Cobertura mínima de 80% para lógica crítica, Cobertura mínima de 85% para funções críticas, Cobertura mínima de 80% para tipos e lógica</coverage_requirements>
    <test_patterns>AAA (Arrange-Act-Assert), AAA, Given-When-Then, AAA (Arrange, Act, Assert), Given-When-Then para testes comportamentais, Arrange-Act-Assert (AAA), Snapshot testing para componentes visuais, Snapshot Testing, Renderização e acessibilidade, Given-When-Then para testes de integração, Given-When-Then para clareza em cenários de eventos, Mocking de hooks e APIs do Chrome, Uso de comentários para descrever ações, Behavior Driven Development (BDD) style, Given-When-Then para testes de fluxo, Testes unitários e de integração para UI e lógica, Testes de integração para import/export, Não especificado, Snapshot Testing para componentes visuais, Behavior Driven Testing, AAA (Arrange-Act-Assert), mocks para API Chrome, Mock de DOM e eventos, Testes unitários focados em comportamento</test_patterns>
    <mocking_approach>jest.mock for modules, jest.mock, fixtures, Mocks para APIs de navegador, Fixtures para dados de entrada, Mocks com Jest e ts-jest, Mocks via Jest para dependências externas e APIs de browser, Mocks para APIs do Chrome e comunicação externa, Mocks para APIs do Chrome, Fixtures para estados de gravação, Mocks para chrome.runtime e window.postMessage, Mocks para dependências externas se houver, Mock de assets estáticos para testes, Mocks para props e funções callback, Mocks para chrome API usando jest-mock-chrome, Fixtures para gravações simuladas, Mock de localStorage e chrome.storage APIs, Mock de APIs chrome.storage e chrome.tabs usando jest-mock, Mock de funções auxiliares e tipos externos, Mock de funções genCode para isolar testes UI, Mock de eventos DOM e APIs do navegador, Fixtures para ações simuladas, Mocks para props e estilos, Mocks para APIs do navegador e funções globais, Mocks para chrome.storage e eventos DOM, Fixtures para simular diferentes tipos de eventos, Mocks para chrome.runtime.sendMessage e document.querySelector, Mocks for browser APIs and storage, Mocks para dependências externas e estilos, Mocks para DOM APIs e querySelectorAll, Mocks para APIs externas não presentes no código analisado, Mocks para finder e elementos DOM, Mocking de módulos estáticos via Jest mocks, Mocks para APIs do navegador, Mocks para simular eventos e ações, Mocks para Webpack e WebpackDevServer APIs, Mocks para Date.now() para controle de tempo em testes, Jest spies para interceptar chamadas de métodos, Uso mínimo de mocks, testes end-to-end reais com navegador, Mocks para hooks useReplay e APIs de clipboard, Fixtures para dados de gravação, Mock de RecordingService para simular respostas e erros, Mock de recordingStore para isolar testes, Fixtures para gravações de exemplo, Não especificado, Mocks para backend de persistência, Mocks para APIs e serviços externos, Mocks para callbacks e props, Mock de APIs Web (Blob, URL) para testes isolados, Não aplicável - funções puras sem dependências externas, Mocks para APIs de dados e eventos de usuário, Fixtures para estados de gravação e erro, Mocks para APIs de arquivos e eventos DOM, Uso de jest.mock para dependências externas, Mock de chrome.runtime e chrome.tabs para simular mensagens e eventos, Mock de dependências externas e injeção de mocks, Mock de APIs do Chrome via jest-mock-chrome, Mocks para MutationObserver, window e document APIs, Mocks para ações e estados, fixtures para mensagens de replay</mocking_approach>
  </testing_strategy>
  <development_workflow>
    <branch_strategy>GitHub Flow, Não especificado explicitamente, GitHub Flow com branches feature, main protegida, GitHub Flow com branches feature, main e hotfix, Git Flow, Não especificado, Git Flow com branches feature, develop e main</branch_strategy>
    <commit_conventions>Conventional Commits, Não especificado explicitamente, Conventional Commits para padronização e automação, Conventional Commits para mensagens padronizadas, Não especificado</commit_conventions>
    <pr_requirements>Code review mandatory, CI checks, code review obrigatório, checks automáticos, Revisão obrigatória, Checks de CI passando, Code review obrigatório, Checks de CI, Husky para hooks de pré-commit e lint-staged para formatação automática, Revisão obrigatória e testes aprovados, Checks de lint e testes, Checks automáticos de lint e testes, Revisão obrigatória por pelo menos 2 desenvolvedores, Revisão obrigatória e testes passando antes do merge, Revisão obrigatória e testes automatizados, Revisão obrigatória por pelo menos um peer, Checks automáticos de lint, build e testes, Revisão obrigatória e testes automatizados aprovados, CI checks passing, Testes passando, Checks automáticos, Build deve passar sem erros, Testes automatizados passando, Revisão obrigatória por pelo menos 1 peer, Revisão obrigatória por pelo menos um revisor, testes automáticos aprovados, Não especificado, Revisão obrigatória por pelo menos um revisor, Code review obrigatório e testes aprovados, Revisão obrigatória por pelo menos 2 membros, Revisão obrigatória, testes automáticos e lint passing, Revisão obrigatória, testes aprovados, linting sem erros, Revisão obrigatória por pelo menos um membro</pr_requirements>
    <ci_cd_pipeline>Linting, Testing, Build, build, test, deploy, Testes unitários e E2E, Lint, Deploy para Chrome e Firefox, Execução de testes automatizados, Testes automatizados com Jest, Linting e formatação via Prettier e ESLint, Build, lint, test e deploy automatizados, Test, Deploy para staging, Build, Test, Lint, Deploy, Build, lint, test e deploy automatizados via GitHub Actions, Build, Test, Lint, Deploy stages, Pipeline com etapas de build, lint, test e deploy automatizado, Deployment to Chrome Web Store, Build, Test, Lint, Deploy automáticos, Testes, Deploy automático, Build automatizado via CI, Deploy condicionado a build sem erros, Build, Test, Lint, Deploy Staging, Deploy automático em staging, Build da extensão, Deploy automatizado, Pipeline com etapas de build, lint, test e deploy automático, Testes unitários e integração, Não especificado, Deploy automático para staging, Testes unitários, Build, Test, Lint, Deploy automatizados via GitHub Actions, Build, Test, Lint, Deploy para ambiente staging e produção, Build, Test, Lint, Deploy automatizados</ci_cd_pipeline>
  </development_workflow>
  <commands>
    <setup>npm install, yarn, yarn install &amp;&amp; yarn prepare, npm install ou yarn install, git clone &lt;repo-url&gt; &amp;&amp; cd &lt;repo&gt; &amp;&amp; npm install, npm install &amp;&amp; npm run setup, npm install &amp;&amp; npm run setup-db</setup>
    <install>npm install, yarn install, npm ci</install>
    <dev>npm start, npm run dev, yarn run start-chrome, yarn run start-ff, yarn start-chrome (para Chrome), yarn start-ff (para Firefox), yarn start, npm run watch, npm run start, node scripts/start.js</dev>
    <test>npm test, yarn test, npm run test, npx cypress open</test>
    <build>npm run build, yarn run build-chrome, yarn run build-ff, yarn build-chrome, yarn build-ff, yarn build, node scripts/build.js</build>
    <lint>npm run lint, eslint src/ --ext .ts,.tsx, eslint ., yarn lint</lint>
    <format>npm run format, prettier --write src/, prettier --write ., yarn format</format>
  </commands>
  <security_constraints>
    <authentication_method>OAuth2 para comunicação externa (deploysentinel.com), OAuth2 (externo, não implementado neste módulo), OAuth2 via DeploySentinel Webapp, OAuth2 para acesso à API do Chrome (implícito), Nenhum método de autenticação implementado diretamente neste módulo, Não aplicável (componente UI local), Não aplicável diretamente (foco em captura local de eventos), OAuth2 via Chrome Extension permissions, Nenhum método explícito no código (depende do navegador), Nenhum método de autenticação implementado, Não aplicável (biblioteca client-side), Nenhum método de autenticação implementado neste arquivo, Nenhum método de autenticação implementado no código de teste, Autenticação via token JWT (externo ao componente), Não aplicável no componente (assumido controle externo), Não implementado no serviço (deve ser tratado externamente), Não aplicável (contexto local de extensão), Não aplicável diretamente no módulo de histórico, N/A (funcionalidade client-side sem autenticação), JWT com expiração curta, OAuth2 via Google Account para acesso à extensão (externo ao hook), OAuth2 via Chrome Identity API (externo ao handler), OAuth2 (externo ao módulo), Token-based authentication (JWT) presumido</authentication_method>
    <authorization_rules>Permissões restritas via manifest para domínios e APIs específicas, Gravação restrita à aba e frame autorizados, Scripts injetados apenas em contextos validados, Validação de origem das mensagens, Permissões restritas na extensão, Permissões restritas no manifest.json para acesso a tabs e storage, Controle de acesso baseado em permissões do navegador para execução de scripts, Não aplicável, Acesso restrito ao armazenamento local do navegador, Eventos filtrados para evitar captura de dados sensíveis de overlays, Permissões restritas para comunicação entre extensão e UI, Controle de acesso via permissões da extensão no manifest, Nenhuma regra de autorização aplicada, Controle de acesso via contexto do navegador isolado, Controle de acesso para visualização e execução de gravações via backend, Confirmação explícita para exclusão de gravações, Não implementado no serviço (requer controle externo), Controle de acesso deve ser implementado externamente, N/A, Controle baseado em roles e permissões granulares, Permissões restritas para acesso a tabs e runtime no manifesto da extensão, Controle de acesso via permissões do Chrome Extension manifest, Controle de acesso via background script, não exposto no replay, Controle de acesso baseado em roles para iniciar e monitorar replay</authorization_rules>
    <sensitive_data>Dados de interação do usuário tratados localmente, sem envio externo não autorizado, URLs e dados de navegação armazenados localmente, sem exposição externa, URLs de teste, Códigos de gravação, URLs e ações do usuário são tratados como dados sensíveis e armazenados localmente, URLs capturadas durante gravação são armazenadas localmente sem criptografia, Password inputs are masked with asterisks, Senhas mascaradas em ações de input, Campos password detectados e marcados para tratamento especial, Nenhum dado sensível manipulado diretamente, Dados de gravação de testes armazenados localmente, sem exposição externa, Client ID anonimamente gerado, sem dados pessoais, Não manipula dados sensíveis, Campos de senha marcados com isPassword para tratamento especial, Arquivos .env locais, secrets.*.js, Dados do usuário armazenados temporariamente em /tmp, URLs e dados de gravação tratados com cuidado para não expor credenciais, Dados de gravação tratados localmente, sem exposição direta, URLs e ações de usuário armazenadas, devem ser protegidas, Dados de gravação de ações do usuário, tratados localmente sem exposição externa, URLs e código gerado podem conter dados sensíveis e devem ser protegidos, Dados pessoais criptografados em repouso e em trânsito, Nenhum dado sensível manipulado diretamente pelo hook, IDs de gravação e URLs tratados com cuidado, não expostos externamente, Nenhum dado sensível manipulado diretamente neste módulo, IDs de gravação e erros devem ser tratados com confidencialidade, Sanitização de URLs para evitar execução de scripts maliciosos</sensitive_data>
    <security_headers>Content Security Policy configurada via manifest, Não aplicável diretamente neste módulo, Content-Security-Policy para mensagens, Content Security Policy configurada no manifest para evitar injeção, Gerenciados pelo navegador, não aplicados diretamente no código, Não aplicável no contexto do código cliente, Cabeçalhos padrão do Chrome Extension, Gerenciados pelo navegador e manifest da extensão, Não aplicável, Access-Control-Allow-Origin: *, Não aplicável diretamente no código de teste, Cabeçalhos padrão aplicados pelo servidor (CSP, CORS, etc.), Gerenciados pela aplicação host, não pelo componente, Não aplicável diretamente, N/A (funcionalidade client-side), Content-Security-Policy, X-Frame-Options, Strict-Transport-Security, Cabeçalhos CSP configurados no manifesto da extensão, Content Security Policy definido no manifest, Gerenciados pelo servidor, não aplicável diretamente, CSP, X-Content-Type-Options, X-Frame-Options</security_headers>
    <encryption_requirements>Criptografia padrão do Chrome para armazenamento local, Dados armazenados via chrome.storage.local, criptografia dependente do navegador, TLS para comunicação web, Dados armazenados localmente não são criptografados, mas acesso é restrito ao contexto da extensão, Nenhuma criptografia aplicada no armazenamento local, Persistência local sem criptografia explícita, depende do ambiente do navegador, Comunicação segura via mensagens internas do Chrome, Nenhuma criptografia explícita no código, Não aplicável, Nenhuma criptografia aplicada, Transmissão via HTTPS obrigatória, Não aplicável diretamente no componente, Não especificado, recomendada criptografia em trânsito e em repouso, Não especificado, armazenamento local sem criptografia explícita, Persistência deve garantir criptografia em repouso conforme política da organização, N/A, TLS 1.3 para comunicação, AES-256 para dados armazenados, Comunicação interna via mensagens Chrome API, sem criptografia adicional, Comunicação interna via mensagens do Chrome, criptografia implícita pelo browser, Comunicação via Chrome Runtime Messaging segura por padrão, Criptografia TLS para comunicação entre cliente e servidor</encryption_requirements>
  </security_constraints>
  <performance_requirements>
    <response_time_limits>Gravação em tempo real sem impacto perceptível na navegação, Atualizações de estado e injeção de scripts devem ocorrer em milissegundos para não impactar UX, Mensagens processadas em &lt; 100ms, Renderização instantânea do componente, Renderização instantânea do logo, Finalização da gravação deve ocorrer em menos de 500ms para boa UX, Operações de armazenamento e execução de scripts devem ser rápidas para não impactar UX, Atualização da UI em tempo real com throttling para mousemove (100ms), Eventos processados em tempo real com debounce para resize (300ms), Interação do botão deve ser instantânea (&lt;100ms), Interação UI responsiva, sem bloqueios perceptíveis, Renderização inicial rápida (&lt; 200ms), Resposta em milissegundos para seletores simples, Limite configurável para tentativas, Baixa latência para hot reload e rebuild incremental, Timeouts configurados para espera de service workers (15s no Jest, 5s na espera explícita), Renderização da UI em menos de 200ms para datasets típicos, Carregamento e filtragem devem ser responsivos, idealmente &lt; 200ms para datasets moderados, Operações CRUD devem responder em milissegundos para volumes moderados, Operações de salvamento com debounce para evitar latência excessiva, Operações CRUD devem responder em menos de 200ms em ambiente típico, Download deve ser disparado imediatamente após chamada, Funções síncronas com tempo de execução constante e baixo, Renderização rápida para manter fluidez na navegação e troca de abas, API responses &lt; 300ms em média, Atualizações de estado em tempo real com latência mínima (&lt;100ms), Resposta a mensagens em até 100ms para boa UX, Ações devem ser executadas com retry e delays controlados, máximo 3 segundos entre ações, Atualizações de status em tempo real com latência abaixo de 200ms</response_time_limits>
    <optimization_priorities>Developer experience, Fast refresh, build speed, bundle size, Baixa latência na captura de eventos, Uso eficiente de memória durante gravação, Performance na captura e geração de scripts, Minimização do bundle final, Baixo impacto em CPU e memória do navegador, Minimizar overhead em abas monitoradas, Baixa latência na comunicação, Baixa complexidade, foco em renderização rápida, Minimizar bundle size, Carregamento rápido, Prioridade em velocidade de resposta e baixa latência na comunicação entre abas, Consistência e sincronização em tempo real priorizadas, Baixa latência na manipulação de estado e execução assíncrona eficiente, Rendering performance to handle large action lists, Renderização rápida, Baixa latência na geração de código, Responsividade da interface, Minimizar impacto no DOM, Baixa complexidade computacional, Minimizar impacto no DOM principal, Isolamento via shadow DOM para performance UI, Minimizar overhead no thread principal do navegador, Evitar gravação excessiva e duplicada de eventos, Baixa latência e mínimo impacto na UI, Velocidade e fluidez na UI, baixo overhead na gravação, Baixa latência na coleta de eventos, mínimo impacto no UX, Velocidade de renderização e carregamento CSS, Balancear velocidade e seletor curto/legível, Equilíbrio entre legibilidade do código e performance na geração, Precisão e estabilidade dos seletores, Minimizar overhead na geração, Build time efficiency, Minimal runtime overhead, Baixa latência na captura e reprodução de ações, Build rápido e eficiente, Compatibilidade com browsers legados, Build otimizado para produção com minificação e tree shaking, Velocidade de feedback em desenvolvimento, Minimizar latência na validação e migração de timestamps, Estabilidade e confiabilidade dos testes priorizadas sobre velocidade, Fast rendering, Minimal repaint on hover, Prioridade para responsividade e fluidez da UI, Prioridade para responsividade UI e experiência do usuário, Font loading performance, Rendering smoothness, Equilíbrio entre velocidade e memória, foco em responsividade, Minimizar chamadas ao storage para preservar performance e evitar bloqueios, Priorizar velocidade de acesso e baixa latência, UI responsiveness, Low memory footprint, Renderização rápida e leve, Baixo consumo de memória, Smooth scrolling, Renderização rápida e leve para UI, Performance visual e responsividade, Transições suaves para melhor UX, Responsividade visual, Transições suaves, Responsividade, Suavidade nas animações, Baixo impacto visual, Baixa latência na criação e disparo do download, Velocidade e simplicidade, Prioridade em velocidade e responsividade sobre uso de memória, Responsividade e fluidez visual, Minimizar repaints e reflows, Visual consistency, Responsividade em resolução 800x600, Prioridade em velocidade de resposta sobre uso de memória, Baixa latência e responsividade UI priorizadas sobre uso de memória, Minimizar impacto na carga inicial, Separação de responsabilidades para otimização, Baixa latência na injeção e execução de scripts, uso eficiente de memória, Confiabilidade e precisão sobre velocidade bruta, Baixa latência e uso eficiente de memória durante replay</optimization_priorities>
    <caching_strategy>cache intermediário de build, Uso de chrome.storage.local para persistência eficiente, Uso de chrome.storage.local para persistência leve, Não aplicável, Cache do navegador para assets estáticos, Uso de localStorage para cache temporário das gravações, Uso de localStorage e chrome.storage para persistência local, Uso do chrome.storage.local como cache persistente local, Uso de chrome.storage.local para persistência e sincronização, Nenhuma estratégia de cache implementada, Uso de armazenamento local para persistência de gravações, Cache de CSS via webpack e browser, Nenhum cache persistente implementado, Uso de cache via Webpack para builds incrementais, Webpack caching padrão para builds incrementais, Uso de userDataDir para persistência temporária do contexto do navegador, ReplayMode permite controle de cache para otimizar replays, Caching interno via estado React, sem cache persistente explícito, Não implementado, possível melhoria futura, Uso de cache interno temporário (pendingSaves) para agrupar operações, Cache local em memória para listagem recente, URLs temporárias revogadas após uso para liberar memória, Cache em memória com TTL de 5 minutos para dados estáticos, Sem caching explícito no hook, estado mantido em memória React, Cache local via recordingStore para gravações, Cache do navegador pode ser limpo via função clearCacheAndReload, Suporte a modos KEEP_CACHE e CLEAN_CACHE para controle de cache do navegador</caching_strategy>
    <scalability_considerations>paralelização de tarefas, Suporte a gravações longas sem degradação perceptível, Suporte a múltiplas abas e sessões simultâneas, Suporte a múltiplas abas e frames, porém foco em uma aba de gravação por vez, Escalabilidade limitada ao ambiente do navegador, Componente leve e reutilizável para múltiplas instâncias, Escalabilidade limitada ao ambiente local do browser, foco em eficiência local, Escalabilidade limitada ao contexto de extensão de navegador, foco em eficiência local, Component designed to handle dynamic and potentially large arrays of actions, Gerenciamento eficiente de lista de ações para gravações longas, Evitar múltiplas instâncias para reduzir uso de memória, Suporte a múltiplos eventos simultâneos e navegação SPA, Escalabilidade limitada ao contexto da extensão e UI do Cypress, Escalabilidade limitada ao contexto de extensão de navegador, Suporte a múltiplos temas e componentes dinâmicos, Pode degradar em documentos muito grandes devido à combinatória, Suporte a grandes volumes de ações sequenciais, Escalabilidade limitada ao ambiente local de desenvolvimento, Operações em arrays grandes devem ser eficientes e imutáveis, Testes isolados para permitir execução paralela, Componentização facilita escalabilidade e manutenção, Adequado para volumes moderados de gravações; para grandes volumes, backend deve suportar paginação, Dependência do storage externo para escalabilidade horizontal, Limitação do número máximo de entradas para evitar crescimento descontrolado, Suporte a crescimento linear no número de gravações com poda automática, Suporte a tabelas com overflow e scroll vertical, Layouts adaptativos para múltiplos dispositivos, Scrolls otimizados para listas grandes, Escalabilidade não aplicável, operação local no browser, Funções puras facilmente escaláveis e reutilizáveis, Suporte a múltiplas gravações e estados sem perda de performance, Suporte a tabelas com grande volume via scroll e overflow, Arquitetura preparada para escalabilidade horizontal via containers, Suporte para múltiplos replays sequenciais, mas não simultâneos, Modularidade facilita escalabilidade e manutenção, Gerenciamento de múltiplas abas simultâneas com estados isolados, Escalabilidade horizontal via múltiplas abas, sem estado persistente local, Capacidade de executar múltiplos replays simultâneos em diferentes tabs</scalability_considerations>
  </performance_requirements>
  <error_handling>
    <error_format>logs padronizados, Logs estruturados para erros no background e content scripts, Erros lançados via throw, sem padrão estruturado explícito, Não especificado no código atual, Logs de erro no console com mensagens claras e stack trace, Erros retornados via Promise reject com objetos Error padrão, Não explícito no código, Não há formato explícito, erros são tratados silenciosamente para não interromper captura, Erros lançados via throw new Error com mensagens claras, Erros lançados como Exceptions, sem tratamento global visível, Tratamento silencioso, sem propagação de erros, Erros lançados via throw com mensagens claras, Try-catch silencioso para evitar falhas na geração de seletores, Logs detalhados no console com stack trace e detalhes, Nenhum formato de erro customizado implementado, Erros lançados via exceptions padrão do JavaScript, Mensagens de erro exibidas no componente com ícones e texto claro, Mensagens de erro exibidas via notificações visuais com tipo &apos;success&apos; ou &apos;error&apos;, Erros lançados como Exceptions com mensagens claras, Erros lançados com mensagens claras, logs no console para diagnóstico, Erros retornam Promise rejeitada com objeto Error padrão, Erro lançado com mensagem clara em caso de falha no download, Retorna string vazia ou texto original, sem lançar exceções, Estados visuais claros para erros com cores e ícones específicos, JSON padrão com código, mensagem e detalhes opcionais, Strings simples para mensagens de erro, armazenadas no estado error, Objetos com campos success:boolean e error:string, Objeto com campos success:boolean, error:string, duration:number, Erro representado como string opcional em mensagens e estados</error_format>
    <logging_strategy>console logs, arquivos de log, Logs locais para debug durante desenvolvimento, Relatórios de erros via CI, Console logs e armazenamento local para diagnóstico, Não explícito no código, presumivelmente console.log para debug, Não implementado explicitamente, Uso de console.error para erros críticos durante persistência, Não implementado explicitamente neste módulo, Sem logging explícito no código fornecido, Logs mínimos, foco em erros críticos, Sem logging explícito no código analisado, Não implementa logging interno, Console.error para erros, console.warn para avisos, Logs padrão do Webpack e WebpackDevServer, Uso de console.warn para alertas de timestamps inválidos, Uso implícito de mensagens de erro via Jest, Logs de console para eventos importantes e erros, Logs de console para operações críticas (carregamento, exclusão, importação, exportação), Logs detalhados para operações de importação e exportação, Uso de console para logs, warnings e erros, Uso de console.warn e console.error para alertas e erros, Logs de operações críticas e falhas via sistema externo, Logs no console para sucesso e erro, Logs estruturados com níveis info, warn, error, Logs internos não expostos, erros capturados e exibidos via UI, Logs básicos via console, erros capturados e enviados via mensagens, Console.error para erros internos, mensagens via chrome.runtime para status, Logs estruturados para estados e resultados de execução</logging_strategy>
    <monitoring_tools>GitHub Actions para monitoramento de build e testes, Integração com ferramentas externas via deploysentinel.com, Não especificado, Possível integração com ferramentas externas, Monitoramento via ferramentas externas integradas ao ambiente de desenvolvimento, Dependência de ferramentas externas para monitoramento do ambiente, Monitoramento via ferramentas da extensão Chrome, Não aplicável, Nenhuma ferramenta de monitoramento integrada, Integração externa para monitoramento (não detalhado no código), Não especificado no componente, presumivelmente externo, Não especificado no código, Integração com Sentry ou similar para monitoramento de erros, N/A, Sentry para erros, Prometheus para métricas, Monitoramento externo via Sentry ou similar (não mostrado no código), Monitoramento externo via ferramentas integradas ao ambiente de produção, Monitoramento externo via logs do background script, Integração com sistemas de monitoramento externos (ex: Sentry)</monitoring_tools>
    <error_recovery>retry automático em falhas de build, Recuperação de falhas na gravação com possibilidade de reinício, Reinício automático do service worker e re-injeção de scripts, Verificações preventivas para evitar estados inválidos, mas sem fallback robusto, Nenhuma estratégia explícita, Fallbacks para obtenção da URL inicial e limpeza do estado para evitar corrupção, Tratamento básico de erros via rejeição de Promises e fallback para criação de IDs, Reinicialização da gravação via UI, Função cleanUp para desmontar e liberar recursos, Reset de flags de eventos para evitar bloqueios em caso de falhas, Retry para seleção de elementos DOM com limite de tentativas, Fallbacks básicos via estado UI, mas sem estratégias robustas, Try/catch para evitar falhas visíveis ao usuário, Fallbacks em busca de seletores alternativos, Fallback para null em seletores quando falha a geração, Abortar build em caso de erro crítico, Hot Module Replacement para recuperação rápida de erros em desenvolvimento, Correção automática de timestamps inválidos e negativos, Rejeição de promises em timeout para falha controlada, Fallback para código antigo se geração de template falhar, Botões desabilitados para evitar ações inválidas, Recarregamento automático após importação e exclusão; notificações para feedback, Tratamento parcial com mensagens e continuação em importação parcial, Tratamento de erros com fallback para evitar falhas críticas, especialmente em operações assíncronas, Tentativas de retry para operações de persistência falhas, Erro é lançado para ser tratado externamente, sem retry automático, Retorno seguro para entradas inválidas ou vazias, Interface permite re-tentativas e feedback visual imediato, Retries automáticos em falhas temporárias, fallback para operações críticas, Reset do estado e possibilidade de nova tentativa via startReplay, Limpeza automática do estado após erro ou conclusão para evitar inconsistências, Retry automático com delay configurável, aborta após tentativas esgotadas, Retry automático configurável via ActionExecutorOptions</error_recovery>
  </error_handling>
  <dependencies_context>
    <critical_dependencies>react-app preset, react-hot-loader, Webpack, Babel, Node.js, APIs de extensão do Chrome e Firefox, Frameworks de teste suportados, @jest/types, ts-jest, React, Jest, Husky, Prettier, chrome.* APIs, background.bundle.js, bridge.bundle.js, APIs do Chrome, Módulos internos utils, recording-store, replay-handler, chrome.runtime API, window.postMessage, React 18, react, logo.svg, typescript, chrome.tabs API, RecordingService, genCypressCode, chrome.storage API, localStorage utilities, chrome.storage.local, chrome.tabs, chrome.scripting, chrome.webNavigation, browser API para compatibilidade Firefox, ../types, ../builders/selector, react-syntax-highlighter, genCode function, Recorder module, Selector builders, Chrome Storage API, Highlighter.css, ReactDOM, FontAwesome, Shadow DOM API, lodash.debounce para otimização de eventos resize, chrome.storage.local para persistência, chrome.runtime para comunicação background, Chrome Extension Messaging API, Chrome Extension APIs, recordingStore, getRandomInstallId, Google Analytics API, react-dom, webpack css-loader, @fortawesome/fontawesome-svg-core, DOM API do navegador, Cypress, TemplateRenderer, Types e enums do projeto, finder, TypeScript compiler, Module bundler (Webpack, Vite), chrome API, TypeScript, webpack, webpack.config.js, process.env (Node.js), webpack-dev-server, path, env, node_modules, secrets.*.js, Type definitions from &apos;../types&apos;, CypressScriptBuilder, truncateText, playwright, jest, chromium browser, useReplay hook para controle do replay, genCypressCodeWithTemplate para geração do código, react-copy-to-clipboard para cópia, FontAwesome Icons, Roboto font, CSS variable --bg-dark, genCypressCodeWithTemplate, Tipos externos (RecordingEntry, HistoryConfig, Action), Action interface do módulo &apos;./index&apos;, Cypress para geração de código, CSS variables defined globally, React index.jsx import, ../themes/dark-core.css, font-awesome, LayoutWrapper.css, Variáveis CSS para tema, Font icons para elementos visuais, CSS variables definidas globalmente, SVG icons, Variáveis CSS globais, JavaScript para manipulação de estado, Variáveis CSS customizadas (ex: --bg-dark, --bg-darker), Browser Web APIs (Blob, URL, DOM), Variáveis CSS globais para cores e espaçamentos, React para renderização do componente, CSS Variables, React (para lógica associada), Nenhuma dependência externa explícita, Express, Mongoose, Joi, chrome.runtime, chrome.tabs APIs, replay-handler.js, types/replay.js, replay-runner (injeção externa), Chrome Extensions API, recordingStore para persistência, Chrome Runtime Messaging API, MutationObserver API, Typescript types do projeto, Browser Cache API</critical_dependencies>
    <deprecated_packages>Nenhum identificado, Nenhum pacote deprecado identificado, Uso de chrome.tabs.executeScript (deprecated no Manifest V3, substituído por chrome.scripting), Nenhum pacote deprecado atualmente</deprecated_packages>
    <version_constraints>Compatibilidade com versões recentes do Chrome e Firefox, Compatibilidade entre Jest 29.x e ts-jest, React 17.x, TypeScript 4.1.x, Jest 27.x, Webpack 5.x, Manifest Version 2 (deprecado em breve), Manifest V3 obrigatório para compatibilidade, Compatibilidade com Chrome API atual, Compatibilidade com Chrome 90+, React &gt;=18.0.0, React 18.x, TypeScript 5.x, Compatibilidade garantida com Chrome 100+ e TypeScript 5.0, Compatibilidade com Manifest V2 e V3 do Chrome Extensions, TypeScript &gt;=4.0, TypeScript &gt;=4.9, TypeScript 4.x, Compatibilidade com versões recentes do Chrome e navegadores baseados em Chromium, Webpack &gt;=5.0.0, Compatível com navegadores modernos suportando querySelectorAll, Compatibilidade com Cypress 12.x e TypeScript 4.x, target ES5, module ESNext, webpack &gt;=5.0.0, Compatibilidade com Webpack 5 e Node.js 16+, TypeScript &gt;= 4.9, TypeScript &gt;=5.0, Jest &gt;=29, Cypress &gt;=12, Jest timeout configurado para 15000ms, FontAwesome 6.x, TypeScript 4.x compatível, API chrome.storage local padrão, Node.js &gt;=20, React &gt;=18.0, TypeScript &gt;=5.0 para suporte a features usadas, Dependências travadas em versões específicas para estabilidade, React &gt;=18.0, TypeScript &gt;=5.0, Chrome API compatível com Manifest V3, Node.js &gt;=18</version_constraints>
    <internal_packages>Módulos internos para gravação e geração de scripts, ../Common/utils, ../storage/recording-store, ../../modules/replay/replay-handler, Módulos internos da extensão DeploySentinel, ../../pages/Popup/logo.svg, ../types (ScriptType), utils, builders, storage, types, ./utils, ../types, Módulos internos organizados por funcionalidade (storage, scripts, utils), types, builders, components, ../builders, ../Common, ./recorder, ./Highlighter, Highlighter.css (estilos locais), ./ControlBar, ../Common/styles.css, builders/selector para geração de seletores CSS, Common/utils para abstração de localStorage, ../Common/Icon, ../Common/hooks, ../Common/endRecording, Common, Content, storage, ./Popup, ./components, ./themes, ../generators/template/TemplateRenderer, finder, config/webpack.config.js, ./env, ../webpack.config, ../src/pages/builders, Extensão localizada em ./build, Common/utils para download e manipulação de texto, Content/ActionList para renderização das ações, ../../storage/recording-service, ../../types/recording, ../../Common/utils/text, ./recording-store, ../types/recording para tipos compartilhados, Módulo &apos;./index&apos; para definição de Action, themes/dark-core.css, Pacotes internos para utilitários e middlewares, src/types/replay.js para tipos ReplayState, ReplayRequest, etc., ../../types/replay.js, ../../pages/storage/recording-store, ../../types/replay, ../../pages/types/recording, ../../pages/types, ../pages/types/index para tipos Action</internal_packages>
  </dependencies_context>
  <current_challenges>
    <technical_debt>scripts de build pouco modularizados, Suporte limitado para captura de upload de arquivos, Atualização para Manifest V3 necessária para compatibilidade futura, Aprimorar suporte a múltiplos frameworks simultaneamente, Tratamento de erros e sincronização de estado podem ser melhorados, Falta de tratamento de erros robusto, Melhorar tratamento de erros assíncronos e cobertura de testes, Fixação rígida da biblioteca Cypress pode limitar flexibilidade, Manutenção da compatibilidade entre Manifest V2 e V3, Refatoração para eliminar uso de APIs deprecated, Gerenciamento de estado complexo pode ser refatorado para usar context API ou state management externo, Ausência de memoização para evitar re-renderizações desnecessárias, Melhorar tratamento de erros e fallback para browsers sem exportFunction, Gerenciamento de eventos duplicados pode ser aprimorado para casos extremos, Persistência local pode crescer indefinidamente sem limpeza, Correção de bug de múltipla montagem no Firefox, Tratamento de erros e logging insuficientes, Acoplamento forte com Cypress, Ausência de logging e feedback de erro, Ausência de tratamento de erros na renderização, Estilos inline podem dificultar manutenção, Otimização limitada para seletores muito complexos, Implementação pendente para dragAndDrop, Catch silencioso pode dificultar debugging, Refatorar função isSupportedActionType para tipagem mais segura, Configuração hardcoded para localhost e porta fixa, Uso incorreto de &apos;number.isFinite&apos; ao invés de &apos;Number.isFinite&apos;, Uso de setInterval para polling pode ser substituído por eventos mais eficientes, Melhorar tratamento de erros na geração de código, Refatorar para reduzir complexidade do componente, Ausência de paginação para grandes volumes de dados, Dependência de confirmação via window.confirm, Uso de dimensões fixas pode limitar responsividade, Dependência de armazenamento não especificado, Ausência de controle de acesso, Dependência da API chrome.storage local que pode ter limitações de quota, Implementação concreta do backend ainda pendente, Suporte a múltiplas estratégias de persistência, Dependência de variáveis CSS externas pode dificultar manutenção, Dependência de variáveis CSS externas pode causar inconsistência, Dependência de variáveis CSS externas não documentadas, Melhorar mensagens de erro para diagnóstico mais detalhado, Necessidade de migração para CSS-in-JS para melhor manutenção, Dependência de variáveis CSS globais, Falta de estilos focados em acessibilidade, Refatoração de módulos com alta complexidade ciclomática, Tratamento de erros genéricos pode ser melhorado com tipos mais específicos, Melhorar tratamento de erros assíncronos e retry em falhas de injeção, Melhorar tipagem para ações Navigate, Refatorar retry para parametrização mais flexível, Melhorar tratamento de erros e mensagens detalhadas</technical_debt>
    <known_issues>Potential incompatibility of react-hot-loader with React 18+, Limitações na captura de eventos hover em alguns contextos, Limitações na captura de eventos em iframes, Dependência forte do estado local pode causar inconsistências em casos de falha, Dependência exclusiva do Chrome, Possível loop de atualização se onChange não for estável, Possível atraso na obtenção da URL da aba ativa em casos de múltiplas abas, Ausência de tratamento explícito de erros em chamadas assíncronas, Possível inconsistência na execução de scripts em frames múltiplos, Limitações do armazenamento local em volume e performance, Eventos de mouse podem ser afetados por overlays externos, Dependência de estilos externos pode causar falhas visuais, Possível incompatibilidade com browsers não suportados, Tipagem TypeScript ignorada em shadowRoot, Possível perda de eventos em navegação rápida SPA se sincronização falhar, Possível falha na localização de elementos DOM em ambientes customizados, Possíveis condições de corrida em efeitos assíncronos, Modo no-cors limita detecção de falhas na requisição, Dependência forte do container &apos;#app-container&apos; estar presente, Performance pode cair em documentos com muitos elementos similares, FIXME expor action diretamente em ActionContext, DragAndDrop não implementado, Diferenças entre APIs Chrome e Firefox podem causar incompatibilidades, Desabilitação de host check pode causar riscos de segurança, Dependência do relógio do sistema pode causar inconsistências, Timeouts podem causar falhas intermitentes em ambientes lentos, Possível atraso na renderização com grandes volumes de ações, Possível lentidão com muitos registros, Exportação depende do browser suportar Blob e download via link, Fallback visual se variável --bg-dark não estiver definida, Performance pode degradar com grande volume de gravações, Tratamento limitado de URLs inválidas, Possível perda de dados se ocorrer erro durante flushPendingSaves, Possível inconsistência se timestamps forem inválidos, Limite de maxEntries pode causar perda de dados se não gerenciado, Scrollbar customization limited to WebKit browsers, Possível baixa acessibilidade se contraste não for suficiente, Sanitização pode gerar nomes duplicados para títulos iguais no mesmo dia, Possível truncamento excessivo em URLs com domínios muito longos, Scrollbars customizadas podem apresentar inconsistências em alguns browsers, Scrollbar customizada pode não funcionar em todos os browsers, Intermitência em chamadas externas sob alta carga, Possível condição de corrida se aba for fechada externamente durante replay, Dependência da injeção externa do replay-runner pode causar falhas se não gerenciada, Possível perda de estado se aba for fechada abruptamente, Possível falha silenciosa se página não carregar após navegação, Sincronização de estado em múltiplas tabs pode causar inconsistências</known_issues>
    <performance_bottlenecks>build lento em grandes projetos, Uso intensivo de CPU em gravações longas, Injeção repetida de scripts pode impactar performance em abas com muitas atualizações, Nenhum identificado, Operações assíncronas sequenciais podem impactar tempo de resposta, Latência na execução de scripts em abas com múltiplos frames, Throttling aplicado para evitar excesso de renderizações, Eventos de input e wheel podem gerar alta frequência de gravação, Polling para retrySelector pode impactar performance se maxRetries alto, Nenhum identificado explicitamente, Injeção de múltiplos estilos CSS pode impactar tempo de carregamento, Geração combinatória de seletores e múltiplas validações querySelectorAll, Uso de innerText pode impactar performance em elementos grandes, Nenhum gargalo crítico identificado em ambiente local, Espera ativa para service workers pode impactar tempo total dos testes, Re-renderizações desnecessárias ao alterar estados de cópia e replay, Filtragem e ordenação feitas em memória no frontend, Carregamento da fonte externa pode impactar renderização inicial, Listagem e filtragem em memória sem paginação, Operações síncronas bloqueantes evitadas, mas potencial lentidão se histórico crescer muito, Listagem completa pode ser custosa sem paginação, Overflow em listas longas pode impactar performance, Possível lentidão em tabelas muito grandes devido a overflow e transições, Nenhum identificado, operação local e rápida, Renderização de tabelas muito grandes pode impactar performance, Consultas complexas ao banco de dados sem índices adequados, Nenhum gargalo crítico identificado, comunicação assíncrona eficiente, Latência na injeção de scripts em abas com carregamento lento, Delay fixo entre ações pode impactar testes de alta velocidade, Replay com grande número de passos pode impactar memória</performance_bottlenecks>
    <migration_status>Completo para Manifest V3, sem migrações pendentes, Nenhuma migração em andamento, Projeto está estabilizado, sem migrações em andamento, Migração parcial para Manifest V3 com fallback para V2, Migração de dados antigos no armazenamento local implementada, Estável, sem migrações em andamento, Função migrateActionsTimestamp implementada e em uso, Nenhuma migração em andamento detectada, Suporte a formatos antigos e novos na importação, Migração da última gravação implementada e executada sob demanda, Projeto está em produção estável, sem migrações em andamento, Migração para TypeScript em andamento, 60% concluída, Código já migrado para TypeScript moderno e React 18, Migração para Manifest V3 concluída, Migração para TypeScript strict mode em andamento</migration_status>
  </current_challenges>
  <team_preferences>
    <code_review_focus>Preserve hot reload functionality, Code style consistency, performance, manutenibilidade, Clareza e legibilidade do código, Cobertura de testes, Manutenção da tipagem forte, Conformidade com padrões de código, Qualidade do código, Conformidade com padrões de linting, Segurança no uso de permissões, Clareza na separação de responsabilidades entre scripts, Segurança das permissões, Qualidade dos scripts gerados, Consistência de estado, Tratamento assíncrono correto, Segurança na injeção de scripts, Segurança na validação de origem, Clareza na comunicação entre módulos, Consistência visual, Performance de renderização, Simplicidade do componente, Performance, Acessibilidade, Consistência de props, Evitar efeitos colaterais desnecessários, Clareza na manipulação assíncrona, Tratamento robusto de erros, Consistência na nomenclatura e modularização, Consistência de estado e sincronização, Uso correto dos hooks, Persistência correta, Verificação de compatibilidade cross-browser e uso correto de APIs assíncronas, Verificação de tipos, cobertura de testes, clareza na renderização condicional, Consistência com padrões, Clareza na separação de responsabilidades, Uso correto de hooks, Manutenção da performance, Clareza na tipagem, Ausência de efeitos colaterais, Verificação de uso correto do cleanUp, Garantia de não múltiplas instâncias, Verificação de tratamento correto de eventos e prevenção de duplicidade, Garantia de tipagem e uso correto de APIs do navegador, Consistência de hooks, tratamento de estado e mensagens Chrome, Tratamento de estados assíncronos, Tratamento de erros silencioso, Uso correto de async/await, Manutenção da anonimidade, Consistência de estilos, Uso correto de hooks e componentes React, Clareza na lógica de busca, Clareza nos comentários, Uso correto de tipos, Manutenção da arquitetura builder, Tratamento de erros, Clareza na priorização de seletores, Consistência de tipagem, Importação correta de assets, Compatibilidade cross-browser, Clareza e simplicidade do código, Consistência de tipos, Clareza na modelagem de ações, Conformidade com padrões TS e React, Verificação de erros de build e warnings, Conformidade com padrão de código, Verificação de configuração correta do HMR e variáveis de ambiente, Validação de tipos e imutabilidade, Cobertura de testes para casos de timestamp, Clareza e legibilidade, Uso correto de mocks, Clareza nos testes, uso correto de async/await, cobertura de funcionalidades críticas, Performance CSS, Consistência no uso de hooks e estados, Tratamento adequado de estados e efeitos, Acessibilidade e usabilidade, Uso correto de variáveis CSS, Performance de fontes, Validação de erros, Consistência de IDs, Tratamento correto de erros assíncronos, Uso adequado do padrão Singleton, Consistência de tipos e contratos, Cobertura de testes e tratamento de erros, Aderência a padrões de código, Testes de snapshot, Uso correto de props, Estados interativos, Acessibilidade básica, Responsividade, Tratamento adequado de erros, Clareza e simplicidade das funções, Consistência visual e responsividade, Clareza nos estados de erro e carregamento, Uso correto de BEM, Legibilidade, segurança, cobertura de testes, Verificação de tratamento de estados e erros, uso correto de hooks, Consistência na tipagem, Clareza na gestão de estado, tratamento de erros, uso correto do TypeScript, Consistência de tipos, clareza de mensagens, tratamento de erros</code_review_focus>
    <documentation_requirements>Document config changes, documentar scripts de build, Documentação clara para APIs internas e uso da extensão, Documentação clara para configurações e testes, Documentação clara via JSDoc para componentes e funções, Documentação clara para APIs internas da extensão e uso dos scripts, Documentação clara para APIs internas e mensagens entre scripts, Documentação clara para APIs de mensagem, Documentação mínima para componentes simples, Documentação clara de props e comportamento, JSDoc para componentes e funções, Documentação clara para funções públicas e fluxos críticos, Documentação clara dos hooks e efeitos colaterais, Documentação clara para funções assíncronas e manipulação de estado, Documentar componentes e funções com JSDoc, Documentação clara para funções públicas e componentes, Documentação clara para componentes e funções complexas, Documentar funções globais e integração com Firefox, Documentação clara para funções públicas e fluxos de eventos, Documentação clara para hooks e componentes React, Documentação clara para componentes e hooks, Comentários simples e claros, Documentar componentes e props com JSDoc, Documentação clara para funções públicas e opções de configuração, JSDoc para métodos públicos, Comentários explicativos para lógica complexa, Documentar funções públicas com JSDoc, Documentação clara para tipos e módulos, Documentar alias e limitações de compatibilidade, Documentação clara para cada tipo de ação e suas propriedades, Documentação inline com JSDoc, Documentação mínima para scripts de build, Documentação clara para configuração do ambiente de desenvolvimento, Uso consistente de JSDoc para funções públicas, Documentação JSDoc para APIs públicas, Documentação inline para funções complexas e testes, Comentários inline para propriedades específicas, Documentação JSDoc para componentes e funções públicas, Documentação via JSDoc para componentes e funções públicas, Comentários claros sobre variáveis e propriedades usadas, Comentários explicativos em blocos complexos, Documentação JSDoc para métodos públicos e classes, Documentação JSDoc para todas as interfaces públicas, Comentários claros em CSS e JS, Documentação de theming, Documentação clara via JSDoc, Comentários claros em português, Explicação de variáveis e blocos, Comentários claros para seções CSS, Comentários explicativos para variáveis CSS e estados, Comentários claros em português para blocos CSS, Documentação clara via JSDoc para todas as funções públicas, Documentação JSDoc para todas as funções públicas, Comentários CSS explicativos e documentação de componentes, Comentários claros em CSS e documentação de componentes, Comentários claros em português explicando variáveis e seções, Documentação clara para APIs e regras de negócio, Documentação JSDoc para funções públicas e interfaces, Documentação clara para injeção do replay-runner, Explicar fluxos complexos de retry, Documentação JSDoc para todas as interfaces e enums</documentation_requirements>
    <communication_style>Clear and concise comments, comentários claros e objetivos, Comentários objetivos e explicativos, Uso de PRs para discussão, Comentários objetivos e informativos, Comentários objetivos e claros, Uso de PRs para revisão, Comentários objetivos e técnicos, uso de inglês para termos técnicos, Comentários objetivos e técnicos, Comentários objetivos e uso de inglês técnico para termos específicos, Comentários claros e objetivos, Comentários objetivos e explicativos em português com termos técnicos em inglês, Comentários objetivos em português com termos técnicos em inglês, Comentários objetivos e claros, uso de inglês técnico para termos específicos, PRs com descrição detalhada, Comentários objetivos e em português para contexto, Comentários claros e objetivos, uso de português para contexto, Comentários objetivos e técnicos, evitando redundância, PRs pequenos e focados, Comentários em português para contexto, Uso de termos técnicos em inglês, Comentários claros e objetivos em português, Clara e objetiva, foco em comportamento visual, Comentários objetivos e uso de emojis para logs no console, Comentários objetivos e em português, uso de emojis para logs e notificações, Objetivo e técnico, foco em comportamento e impacto visual, Uso de emojis em logs para clareza, Mensagens claras e objetivas, Comentários claros em português explicando lógica e decisões, Comentários claros e objetivos, foco em comportamento e regras de negócio, Objetivo e direto em comentários e PRs, Objetivo e direto, Comentários explicativos, Clara e objetiva, comentários explicativos, Comentários sucintos e objetivos, Objetivo e direto, com foco em usabilidade, Comentários objetivos e técnicos, sem redundância, Comentários objetivos e uso de termos técnicos em inglês para precisão, Objetivo e direto, foco em comportamento e usabilidade, Comentários objetivos e educados, PRs pequenos e focados, Comentários claros e objetivos, sem excesso, Comentários objetivos e técnicos, sem jargões desnecessários</communication_style>
    <decision_log>Opted for react-app preset for simplicity, Enabled react-hot-loader for dev experience, Escolha por TypeScript para segurança de tipos, Suporte multiplataforma (Chrome e Firefox), Adoção do ts-jest para testes TypeScript, Suporte a manifest v2 e v3 para compatibilidade cross-browser, Manter Manifest Version 2 até migração completa para V3, Adoção do Manifest V3 para maior segurança e performance, Uso do chrome.storage.local para estado, Separação clara entre gravação e replay, Uso de mensagens para integração entre webapp e extensão, Uso de SVG para ícones para garantir escalabilidade, Uso de componentes funcionais para UI, Importação estática de assets, Fixar ScriptType como Cypress para compatibilidade, Decisão de usar mensagens runtime para comunicação entre background e tabs, Separação clara entre persistência e geração de código, Decisão de fixar Cypress como biblioteca padrão, Decisão de manter compatibilidade com Manifest V2 e V3 para maior abrangência, Uso de componentes funcionais React para melhor performance e simplicidade, Separação clara entre geração e apresentação de código, Uso de react-syntax-highlighter para UI, Uso de throttle para otimizar eventos de mousemove, Separação entre visualização de ações e código, Uso de componente funcional para simplicidade e performance, Uso de shadow DOM para isolamento, Exposição global para controle externo, Uso de debounce para resize para balancear performance e precisão, Filtragem de eventos de overlay para evitar ruído, Uso de Shadow DOM para encapsulamento do botão na UI, Uso de Cypress como biblioteca padrão para geração de código, Uso do Google Analytics para coleta de eventos, Identificador anônimo para client ID, Adoção de HMR para acelerar desenvolvimento, Uso de CSS-in-JS via injeção para controle de temas, Uso de penalidades para ordenar seletores, Fallbacks para garantir unicidade, Adoção do Cypress como framework principal, Uso do padrão Builder para geração de scripts, Evitar uso de IDs inválidos para seletores, Priorizar atributos de teste e acessibilidade, Uso de declarações de módulos para assets estáticos, Uso de alias para compatibilidade entre Chrome e Firefox, Uso de enums para garantir valores constantes e evitar strings mágicas, Uso de strict mode para evitar erros em produção, Remoção de chromeExtensionBoilerplate para evitar conflito em builds de produção, Uso de HotModuleReplacementPlugin para acelerar desenvolvimento, Separação entre migração e validação de timestamps para clareza e manutenção, Adoção do Builder Pattern para geração de scripts Cypress, Uso de Playwright para testes end-to-end da extensão Chrome, Uso de utilitários CSS para acelerar desenvolvimento, Separação clara entre componentes e utilitários, Uso de react-syntax-highlighter para exibição de código, Separação clara entre modos de visualização (ações vs código), Uso de hooks para estado e efeitos, Separação clara entre UI e serviço de dados, Escolha da fonte Roboto para legibilidade e padrão visual, Manter compatibilidade com geração antiga de código Cypress, Gerar IDs únicos para evitar colisões, Adoção do padrão Singleton para store, Uso de debounce para otimização de salvamento, Uso de interface para backend para permitir flexibilidade de implementação, Adotado dark mode unificado via CSS variables, Scrollbar customizada para WebKit, Uso de SVG inline para performance e flexibilidade, Adoção de dark mode unificado via CSS Variables, Layout fixo para 800x600, Uso de componentes funcionais para melhor performance e simplicidade, Adoção de tema Dark com variáveis CSS para flexibilidade, Adoção de tema Dark via CSS variables, Uso de BEM-like naming para modularidade, Adoção de tema Dark para melhor experiência noturna, Separação entre estilos modernos e legacy, Uso de animações para feedback visual, Uso de nomes sanitizados para evitar erros em sistemas de arquivos, Download via Blob e URL temporária para compatibilidade cross-browser, Manter funções puras para facilitar testes e manutenção, Adoção de tema dark como padrão para melhor conforto visual, Uso de flexbox para layout flexível e responsivo, Adoção do tema dark para melhor experiência visual, Uso de CSS variables para facilitar customização, Uso de CSS variables para facilitar manutenção e customização do tema, Adoção do padrão MVC, uso de JWT para autenticação, Uso de mensagens Chrome API para desacoplamento entre UI e background, Separação do replay-runner para injeção externa para otimizar carregamento, Uso de singleton para estado centralizado do replay, Comunicação via mensagens do Chrome para desacoplamento, Uso de MutationObserver para detectar elementos dinamicamente, Retry com delay para robustez, Uso de mensagens tipadas para comunicação entre módulos</decision_log>
  </team_preferences>
  <api_specifications>
    <api_style>REST para comunicação externa, Event-driven via Chrome Runtime Messaging, Message Passing API via postMessage e chrome.runtime, Chrome Extension Messaging API, APIs do navegador baseadas em callbacks e Promises, Não aplicável - componente UI local, Comunicação via mensagens chrome.runtime (event-driven), Nenhuma API REST ou similar exposta diretamente, HTTP POST via fetch para Google Analytics Measurement Protocol, Função exportada como default, API funcional simples, WebExtension API, Nenhuma API exposta diretamente, Chrome Extensions API, Não aplicável diretamente (frontend), API interna via RecordingService com métodos assíncronos para CRUD e import/export, API interna baseada em métodos assíncronos, Não aplicável (API local chrome.storage), Não aplicável diretamente (API interna via interfaces), N/A (módulo utilitário client-side), RESTful, Mensagens assíncronas via chrome.runtime.sendMessage (event-driven), Event-driven messaging via chrome.runtime.sendMessage e onMessage, Chrome Runtime Messaging API (event-driven), Event-driven, mensagens JSON tipadas</api_style>
    <versioning_strategy>Versionamento semântico para APIs externas, Não aplicável diretamente, Sem versionamento explícito, Sem versionamento explícito, compatibilidade garantida via manifest v3, Compatibilidade com versões de Manifest V2 e V3, Sem versionamento explícito para mensagens, Não aplicável, Sem versionamento interno, gerenciado via npm, Não aplicável diretamente no componente, Não especificado, Versionamento via controle de pacotes e semântico, N/A, Versionamento via URL (/v1/, /v2/), Sem versionamento explícito no protocolo de mensagens, Versionamento via controle de versões do extension manifest, Sem versionamento explícito no módulo, controlado externamente, Versionamento semântico implícito via tipos e enums</versioning_strategy>
    <response_formats>JSON, Objetos JSON simples para mensagens e armazenamento, Objetos JSON simples com propriedades source, type, code, actions, Mensagens JSON com tipo e payload definidos, Objetos JSON simples e Promises para respostas assíncronas, Objetos JSON armazenados localmente com estrutura de ações, Mensagens simples sem payload complexo, Não aplicável, String contendo seletor CSS válido, JSON para importação e exportação de gravações, JSON para exportação e importação, Promises retornando dados ou void, Promises com objetos tipados ou null, N/A, Objetos JSON com campos success, error e tabId, Objetos JSON com campos success, error, tabId, JSON com campos success, error, duration, JSON com campos success, error e dados específicos</response_formats>
    <rate_limiting>Limites impostos pelo serviço externo deploysentinel.com, Não implementado, Não aplicável no contexto local da extensão, Não aplicável diretamente, dependente das limitações do navegador, Controle interno via debounce e flags para evitar excesso de eventos, Nenhuma limitação explícita implementada, Não aplicável, Não especificado, Debounce interno para limitar frequência de gravações, Não aplicável diretamente, N/A, Limite de 100 requisições por minuto por IP, Não aplicável para comunicação interna da extensão, Não aplicável diretamente, controle via UI e estado interno, Não aplicável diretamente, controle via retry e delays, Não especificado no código</rate_limiting>
  </api_specifications>
  <deployment_context>
    <environments>development, production, dev, staging, prod, Development, Production, Localhost (http://localhost/*), DeploySentinel (https://*.deploysentinel.com/*), Development (localhost), Production (Chrome Web Store), Desenvolvimento local, Produção via Chrome Web Store, localhost, deploysentinel.com, *.deploysentinel.com, Staging (testes internos), Desenvolvimento local, staging via builds automatizados, produção via Chrome Web Store, Ambiente browser extension para Chrome e navegadores compatíveis, Ambiente browser, qualquer DOM compatível, development (localhost:PORT), Local development, Test environment, dev, staging, production, URLs variam conforme ambiente, Desenvolvimento local, staging e produção (URLs não especificadas), Desenvolvimento, Staging, Produção, Extensão Chrome local, ambiente browser, dev (dev.example.com), staging (staging.example.com), prod (example.com), Dev, Staging e Produção via builds da extensão Chrome, development (localhost), staging, production (Chrome Web Store), Development (localhost), Staging (staging.example.com), Production (example.com), dev, staging, production com URLs específicas não definidas</environments>
    <deployment_method>Static hosting, CI/CD pipelines, Docker, Kubernetes, Chrome Web Store, Firefox Add-ons Marketplace, Empacotamento como extensão zip para browsers, Chrome Web Store Extension, Publicação via Chrome Web Store, Extensão Chrome empacotada, CI/CD pipeline, Distribuição manual para testes, Publicação como extensão Chrome/Firefox, Web Extension, Static Hosting, Browser extension injection, Distribuição via Chrome Web Store como extensão, Chrome Extension via Web Store, Chrome Extension Packaging and Publishing, CI/CD pipeline via GitHub Actions, Distribuído via npm como biblioteca JavaScript, WebExtension packaging, CI/CD pipeline com deploy automatizado, Local Node.js server, Extensão Chrome carregada localmente via Playwright, Docker containerizado, Deploy via CI/CD pipeline, Deploy via pipeline CI/CD automatizado (provável Docker ou similar), Não especificado, Distribuição via Chrome Web Store, Deploy via CI/CD pipeline para ambiente web, Docker containerizado para front-end, Deploy via CI/CD pipeline automatizado, Docker containers orquestrados via Kubernetes, Chrome Extension package via ZIP upload e CI/CD automatizado, Chrome Web Store deployment via Manifest V3, Docker e Kubernetes presumidos</deployment_method>
    <environment_variables>MANIFEST_VERSION para controle de versão do manifest, URLs autorizadas para comunicação externa, Não aplicável, Nenhuma explícita, CHROME_EXTENSION_ID, API_KEYS (não expostos no código), Nenhum variável sensível exposta neste módulo, Nenhuma variável de ambiente explícita no código, Nenhuma variável sensível exposta no código, Nenhum explícito no código, BABEL_ENV, NODE_ENV, ASSET_PATH, PORT, BABEL_ENV=development, NODE_ENV=development, ASSET_PATH=/, PORT (definido em ./env), .env.local, .env.development.local, .env.test.local, .env.production.local, Nenhum variável de ambiente explícita, REACT_APP_API_URL, REACT_APP_ENVIRONMENT, Não especificadas no componente, --bg-dark, HIST_MAX_ENTRIES, HIST_PRUNE_STRATEGY, --text-primary, --primary, --error, --success-bg, DATABASE_URL, JWT_SECRET, API_KEYS, Variáveis de configuração no build, sem dados sensíveis, CHROME_EXTENSION_ID, API_KEYS (externos ao handler), Nenhum variável sensível no módulo, configurações externas, Variáveis para configuração de URLs, tokens e timeouts</environment_variables>
    <infrastructure_constraints>Limitações das APIs de extensão dos navegadores, Necessidade de builds separados para Chrome e Firefox, Limitação a Manifest Version 2, Permissões restritas pelo navegador, Limitações do Manifest V3 e APIs do Chrome, Limitações da API do Chrome e permissões da extensão, Execução limitada ao ambiente do navegador Chrome, Limitação ao ambiente do navegador Chrome e suas APIs, Limitações do ambiente de extensão de navegador, restrições de API e armazenamento local, Limitações do ambiente de extensão de navegador, Dependência de APIs específicas do navegador, Limitação a ambientes que suportem shadow DOM, Limitações do armazenamento local do navegador e políticas de extensão, Limitações do ambiente de extensão Chrome e compatibilidade com browsers, Limitado ao ambiente de navegador Chrome e APIs de extensão, Necessidade de container DOM &apos;#app-container&apos; disponível no host, Dependência de ambiente DOM e suporte a querySelectorAll, Limitações das APIs suportadas por cada navegador, Necessita Node.js ambiente local, porta disponível para servidor, Necessidade de ambiente com Chromium instalado, Limitação de memória para containers frontend, Necessidade de HTTPS obrigatório, Dependência de browser moderno para APIs Blob e download, Dependência de armazenamento externo para persistência, Limitações de armazenamento do chrome.storage.local (~5MB), Armazenamento persistente confiável para gravações, Limitação de espaço para histórico configurável, Dependência de ambiente browser para execução, Limitações de largura de banda para assets estáticos, Compatibilidade com navegadores modernos e fallback para antigos, Limitação de memória em pods Kubernetes a 512MB, Limitações da API Chrome e sandbox da extensão, Limitações do Chrome Extension Manifest V3, sandboxing e permissões restritas, Limitações do ambiente de extensão Chrome, sandboxing e permissões restritas, Limitações de memória para execução simultânea de replays</infrastructure_constraints>
  </deployment_context>
</system_architecture>

<project_files>
  <relevant_files>
    <directory path=".">
      <file>
        <path>src/pages/Common/endRecording.ts</path>
        <name>endRecording.ts</name>
        <summary>O código implementa a finalização de uma sessão de gravação de ações do usuário em um ambiente de browser automation, garantindo a persistência dos dados capturados e a comunicação com a interface web. Ele recupera do armazenamento local as informações da gravação, identifica a URL inicial relevante para contextualizar a sessão, e salva a gravação no histórico por meio do serviço dedicado. Após a persistência, limpa o estado local para preparar futuras gravações e, se configurado, gera código Cypress correspondente às ações gravadas, enviando-o para a aba de origem. O comportamento é robusto, com tratamento de exceções e múltiplos pontos de decisão para assegurar a integridade dos dados e a continuidade do fluxo de trabalho automatizado.</summary>
      </file>
      <file>
        <path>src/pages/Common/hooks.ts</path>
        <name>hooks.ts</name>
        <summary>Este arquivo contém hooks React customizados que gerenciam preferências e estados relacionados à biblioteca de testes, posição da barra de interface, estado de gravação de ações e configurações de timing. O código centraliza a persistência e sincronização desses estados com localStorage e chrome.storage, garantindo consistência entre sessões e atualizações em tempo real. Destaca-se a fixação da biblioteca Cypress como padrão, a recuperação e atualização da posição da barra, o acompanhamento do estado de gravação com escuta de mudanças externas, e a gestão configurável de parâmetros de timing, todos voltados para melhorar a experiência do usuário e a integridade dos dados no contexto de uma aplicação de automação de testes ou gravação de ações.</summary>
      </file>
      <file>
        <path>src/pages/Common/utils.ts</path>
        <name>utils.ts</name>
        <summary>Este código implementa funcionalidades para gerenciar o estado de gravação e preferências do usuário em uma extensão de navegador, utilizando a API de armazenamento local do Chrome. Ele oferece métodos para iniciar e finalizar gravações, armazenar preferências como biblioteca e posição da barra, além de funções assíncronas para manipulação de abas, execução de scripts e identificação de contextos específicos como testes Cypress. O comportamento central envolve a persistência e recuperação de dados no armazenamento local, controle do fluxo de gravação e integração com APIs do navegador para manipulação de abas e execução de scripts, garantindo uma experiência consistente e configurável para o usuário. A arquitetura suporta compatibilidade entre manifest v2 e v3, e inclui tratamento de erros e limpeza de contexto, promovendo robustez e manutenção eficiente do estado da aplicação.</summary>
      </file>
      <file>
        <path>src/pages/Content/recorder.ts</path>
        <name>recorder.ts</name>
        <summary>O código implementa um sistema de gravação de ações do usuário na interface web, capturando eventos como cliques, inputs, teclas pressionadas, redimensionamentos e interações de drag-and-drop. Utiliza técnicas de debounce para otimizar eventos de resize e filtra eventos irrelevantes ou duplicados, garantindo a integridade e a precisão dos dados coletados. Além disso, integra-se com o armazenamento local do navegador para persistência e sincronização dos dados, suportando comunicação com background scripts para ações contextuais, o que permite um monitoramento detalhado e confiável do comportamento do usuário para fins de análise ou automação.</summary>
      </file>
      <file>
        <path>src/pages/CypressTrigger/index.tsx</path>
        <name>index.tsx</name>
        <summary>Este arquivo implementa um componente React chamado TriggerButton que gerencia o estado de gravação de testes automatizados utilizando a biblioteca Cypress. O código injeta dinamicamente este botão na interface do usuário do Spec Runner do Cypress, permitindo iniciar e encerrar gravações de testes via mensagens enviadas para a extensão do Chrome. Ele utiliza hooks personalizados para definir a biblioteca preferida como Cypress e para monitorar o estado atual da gravação, além de implementar uma função retrySelector para garantir a montagem do botão somente após a disponibilidade dos elementos DOM necessários. O comportamento central é controlar o fluxo de gravação de testes, integrando-se com a extensão do navegador e prevenindo múltiplas montagens do componente, garantindo uma experiência de usuário consistente e responsiva durante a criação de testes automatizados.</summary>
      </file>
      <file>
        <path>src/pages/Popup/Popup.tsx</path>
        <name>Popup.tsx</name>
        <summary>Este arquivo React implementa a interface principal de um popup para uma extensão de navegador focada na gravação e geração de scripts de teste automatizados, especialmente para Cypress. Ele gerencia o estado da gravação de testes, histórico de gravações e visualização detalhada, permitindo ao usuário iniciar, finalizar e revisar gravações, além de visualizar o código gerado ou as ações capturadas. A aplicação integra-se com APIs do navegador para manipulação de abas e frames, além de utilizar hooks customizados para persistência e preferências, promovendo uma experiência fluida e contextualizada para criação de testes automatizados a partir das interações do usuário no navegador.</summary>
      </file>
      <file>
        <path>src/pages/Popup/components/RecordingDetail.tsx</path>
        <name>RecordingDetail.tsx</name>
        <summary>O componente RecordingDetail é uma interface React que exibe detalhes de uma gravação de teste automatizado, permitindo ao usuário visualizar ações capturadas ou o código Cypress gerado para reprodução. Ele gerencia estados internos para alternar entre visualização de ações e código, controla a cópia do código para a área de transferência, possibilita o download do script gerado e oferece funcionalidades para iniciar, monitorar e interromper a reprodução do teste, com feedback visual do status do replay. A integração com hooks personalizados e utilitários auxilia na geração dinâmica do código, manipulação do download e controle do fluxo de replay, garantindo uma experiência interativa e responsiva para análise e execução de gravações de testes automatizados.</summary>
      </file>
      <file>
        <path>src/pages/Popup/components/RecordingHistory.tsx</path>
        <name>RecordingHistory.tsx</name>
        <summary>O componente RecordingHistory é uma interface React que gerencia e exibe um histórico de gravações de sessões, permitindo busca, ordenação, seleção múltipla, exclusão, exportação e importação de dados. Ele mantém estados internos para controlar carregamento, filtros, seleção e notificações, além de interagir com um serviço externo RecordingService para persistência e manipulação dos dados. A interface apresenta uma tabela dinâmica com colunas ordenáveis, suporte a seleção em massa e feedback visual, garantindo uma experiência fluida e responsiva para o usuário final.</summary>
      </file>
      <file>
        <path>src/pages/storage/recording-store.ts</path>
        <name>recording-store.ts</name>
        <summary>Este arquivo implementa um store singleton para gerenciar o histórico de gravações utilizando a API chrome.storage.local, garantindo persistência local eficiente e controle sobre o volume de dados armazenados. Ele oferece funcionalidades para salvar, listar, obter, remover e limpar gravações, aplicando uma estratégia configurável de poda para limitar o número máximo de entradas, evitando crescimento descontrolado do armazenamento. Além disso, inclui um mecanismo de migração para converter gravações antigas em um novo formato estruturado, facilitando a manutenção e evolução do sistema. O uso de debounce para operações de salvamento otimiza a performance, reduzindo chamadas excessivas ao storage. O design modular e o padrão Singleton asseguram uma única instância gerenciadora, promovendo consistência e integridade dos dados no contexto de extensões Chrome ou aplicações que utilizam gravações de ações do usuário.</summary>
      </file>
      <file>
        <path>src/pages/types/recording.ts</path>
        <name>recording.ts</name>
        <summary>O código define interfaces TypeScript para um sistema de histórico de gravações focado em capturar, armazenar e gerenciar sessões de gravação de ações de usuário em páginas web. Ele estrutura dados detalhados como identificadores únicos, timestamps, URLs, ações gravadas e código gerado para testes automatizados com Cypress, além de configurar políticas para gerenciamento do histórico, como limite máximo de entradas e estratégias de poda. A interface backend padroniza operações assíncronas para salvar, listar, recuperar, remover e limpar gravações, garantindo integração consistente e controle sobre o ciclo de vida dos dados de gravação.</summary>
      </file>
      <file>
        <path>src/modules/replay/replay-handler.ts</path>
        <name>replay-handler.ts</name>
        <summary>O ReplayHandler é um componente singleton responsável por gerenciar a execução de replays de gravações de ações do usuário em abas do navegador, coordenando a comunicação entre o popup e o runner. Ele controla a criação e monitoramento das abas, injeta scripts para executar as ações gravadas, atualiza o estado do replay em tempo real e trata resultados, garantindo sincronização e limpeza do estado após a conclusão. Essa funcionalidade habilita a automação e reprodução confiável de fluxos de usuário para testes ou demonstrações, integrando-se ao armazenamento de gravações e ao sistema de mensagens do Chrome.</summary>
      </file>
      <file>
        <path>src/modules/replay/replay-runner.ts</path>
        <name>replay-runner.ts</name>
        <summary>O módulo ReplayRunner é responsável por executar sequências de ações gravadas em uma nova aba do navegador, simulando interações reais do usuário como cliques, digitação e navegação. Ele implementa mecanismos robustos de retry, espera ativa por elementos DOM, e controle de fluxo para garantir a execução fiel das ações, incluindo limpeza de cache e recarga da página quando necessário. A arquitetura do código prioriza a confiabilidade e a integração com o sistema de mensagens do Chrome Extension, permitindo comunicação assíncrona e controle detalhado do progresso e erros durante a reprodução das ações.</summary>
      </file>
      <file>
        <path>src/types/replay.ts</path>
        <name>replay.ts</name>
        <summary>Este arquivo define tipos TypeScript para um sistema de replay de gravações de ações do usuário, incluindo enumerações, interfaces e tipos que modelam o estado, mensagens e resultados do replay. O código estrutura a comunicação entre componentes do sistema, permitindo iniciar, monitorar, executar e reportar o progresso e resultados do replay, com suporte a modos de cache e controle detalhado do estado. A modelagem tipada assegura integridade e clareza na manipulação dos dados, facilitando a integração e manutenção do sistema de replay em aplicações complexas.</summary>
      </file>
    </directory>
  </relevant_files>
</project_files>
</context>
    </onboarding_summary>
  </context_reference>

  <output_format>
    Executar diretamente no Claude Code:
    1. Criar/modificar arquivos necessários
    2. Implementar código production-ready
  </output_format>
</claude_code_execution>